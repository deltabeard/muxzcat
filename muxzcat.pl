#! /usr/bin/env perl
#
# muxzcat.pl: tiny .xz and .lzma decompression filter
# by pts@fazekas.hu at Thu Feb  7 00:19:59 CET 2019
#
# Usage: perl muxzcat.pl <input.xz >output.bin
#
# https://github.com/pts/muxzcat
#
# This file was autogenerated by genpl.sh from muaxzcat.c.
#
BEGIN { $^W = 1 }
# Silence warning about goto-into-while.
BEGIN { eval { require warnings; unimport warnings qw(deprecated) }; }
use integer;  # This is required.
use strict;   # Optional.
# Older versions of Perl lose the value of my $x between nested gotos.
die "fatal: your Perl is too old, upgrade to >=5.8.4\n" if !sub {
    goto a; for (;;) { a: my $x = 1; goto b; for (;;) { b: return $x } } }->();
die "fatal: your Perl does not support integer arithmetics\n" if 1 / 2 * 2;

sub SZ_OK() { 0 }
sub SZ_ERROR_DATA() { 1 }
sub SZ_ERROR_MEM() { 2 }
sub SZ_ERROR_CRC() { 3 }
sub SZ_ERROR_UNSUPPORTED() { 4 }
sub SZ_ERROR_PARAM() { 5 }
sub SZ_ERROR_INPUT_EOF() { 6 }
sub SZ_ERROR_OUTPUT_EOF() { 7 }
sub SZ_ERROR_READ() { 8 }
sub SZ_ERROR_WRITE() { 9 }
sub SZ_ERROR_FINISHED_WITH_MARK() { 15 }
sub SZ_ERROR_NOT_FINISHED() { 16 }
sub SZ_ERROR_NEEDS_MORE_INPUT() { 17 }
sub SZ_ERROR_CHUNK_NOT_CONSUMED() { 18 }
sub SZ_ERROR_NEEDS_MORE_INPUT_PARTIAL() { 17 }
sub SZ_ERROR_BAD_MAGIC() { 51 }
sub SZ_ERROR_BAD_STREAM_FLAGS() { 52 }
sub SZ_ERROR_UNSUPPORTED_FILTER_COUNT() { 53 }
sub SZ_ERROR_BAD_BLOCK_FLAGS() { 54 }
sub SZ_ERROR_UNSUPPORTED_FILTER_ID() { 55 }
sub SZ_ERROR_UNSUPPORTED_FILTER_PROPERTIES_SIZE() { 56 }
sub SZ_ERROR_BAD_PADDING() { 57 }
sub SZ_ERROR_BLOCK_HEADER_TOO_LONG() { 58 }
sub SZ_ERROR_BAD_CHUNK_CONTROL_BYTE() { 59 }
sub SZ_ERROR_BAD_CHECKSUM_TYPE() { 60 }
sub SZ_ERROR_BAD_DICTIONARY_SIZE() { 61 }
sub SZ_ERROR_UNSUPPORTED_DICTIONARY_SIZE() { 62 }
sub SZ_ERROR_FEED_CHUNK() { 63 }
sub SZ_ERROR_NOT_FINISHED_WITH_MARK() { 64 }
sub SZ_ERROR_BAD_DICPOS() { 65 }
sub SZ_ERROR_MISSING_INITPROP() { 67 }
sub SZ_ERROR_BAD_LCLPPB_PROP() { 68 }
sub TRUE() { 1 }
sub FALSE() { 0 }
sub LZMA_REQUIRED_INPUT_MAX() { 20 }
sub LZMA_BASE_SIZE() { 1846 }
sub LZMA_LIT_SIZE() { 768 }
sub LZMA2_LCLP_MAX() { 4 }
sub LZMA2_MAX_NUM_PROBS() { 14134 }
sub DIC_ARRAY_SIZE() { 1610612736 }
sub RC_INIT_SIZE() { 5 }
sub kNumMoveBits() { 5 }
sub kNumTopBits() { 24 }
sub kNumBitModelTotalBits() { 11 }
sub kNumPosBitsMax() { 4 }
sub kLenNumLowBits() { 3 }
sub kLenNumMidBits() { 3 }
sub kLenNumHighBits() { 8 }
sub kNumStates() { 12 }
sub kNumLitStates() { 7 }
sub kStartPosModelIndex() { 4 }
sub kEndPosModelIndex() { 14 }
sub kNumPosSlotBits() { 6 }
sub kNumLenToPosStates() { 4 }
sub kNumAlignBits() { 4 }
sub kMatchMinLen() { 2 }
sub kTopValue() { 16777216 }
sub kBitModelTotal() { 2048 }
sub kNumPosStatesMax() { 16 }
sub kLenNumLowSymbols() { 8 }
sub kLenNumMidSymbols() { 8 }
sub kLenNumHighSymbols() { 256 }
sub LenChoice() { 0 }
sub LenChoice2() { 1 }
sub LenLow() { 2 }
sub LenMid() { 130 }
sub LenHigh() { 258 }
sub kNumLenProbs() { 514 }
sub kNumFullDistances() { 128 }
sub kAlignTableSize() { 16 }
sub kMatchSpecLenStart() { 274 }
sub IsMatch() { 0 }
sub IsRep() { 192 }
sub IsRepG0() { 204 }
sub IsRepG1() { 216 }
sub IsRepG2() { 228 }
sub IsRep0Long() { 240 }
sub PosSlotCode() { 432 }
sub SpecPos() { 688 }
sub Align() { 802 }
sub LenCoder() { 818 }
sub RepLenCoder() { 1332 }
sub Literal() { 1846 }
sub READBUF_SIZE() { (6 + 65536 + 6) }
sub LZMA_DIC_MIN() { (1 << 12) }
sub DUMMY_ERROR() { 0 }
sub DUMMY_LIT() { 1 }
sub DUMMY_MATCH() { 2 }
sub DUMMY_REP() { 3 }
sub FILTER_ID_LZMA2() { 0x21 }

# !! Not all indexes can be more than 32-bit. Optimize away the long ones.
# TODO(pts): Simplify doublings: e.g .LOCAL_VAR(symbol) = (LOCAL_VAR(symbol) + LOCAL_VAR(symbol))
# !! Mask the inputs and outputs of GET_ARY8, GET_ARY16, SET_ARY8, SET_ARY16?
# !! Use *_SMALL more, wherever it works.
# The code doesn't have overflowing / /= % %=, so we don't create macros for these.
# This works in both 32-bit a 64-bit Perl with `use integer'.
sub lt32($$) {
  my $a = $_[0] & 0xffffffff;
  my $b = $_[1] & 0xffffffff;
  ($a < 0 ? $b >= 0 : $b < 0) ? $b < 0 : $a < $b
}
# This works in both 32-bit a 64-bit Perl with `use integer'.
sub shr32($$) {
  my $b = $_[1] & 31;  # !! Make sure we are not doing more.
  $b ? ($_[0] >> $b) & (0x7fffffff >> ($b - 1)) : $_[0]
}
# ---
# Just check that it compiles.
# ---
# ---
# For LZMA streams, LE(lc + lp, 8 + 4), LE 12.
# * For LZMA2 streams, LE(lc + lp, 4).
# * Minimum value: 1846.
# * Maximum value for LZMA streams: 1846 + (768 << (8 + 4)) == 3147574.
# * Maximum value for LZMA2 streams: 1846 + (768 << 4) == 14134.
# * Memory usage of prob: sizeof(GET_ARY16(probs, 0)) * value == (2 or 4) * value bytes.
# #define LzmaProps_GetNumProbs(p) TRUNCATE_TO_32BIT(LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
my($bufCur) = 0;
my($dicSize) = 0;  # Configured in prop byte.
my($range) = 0;
my($code) = 0;
my($dicPos) = 0;
my($dicBufSize) = 0;
my($processedPos) = 0;
my($checkDicSize) = 0;
my($state) = 0;
my($rep0) = 0;
my($rep1) = 0;
my($rep2) = 0;
my($rep3) = 0;
my($remainLen) = 0;
my($tempBufSize) = 0;
my($readCur) = 0;  # Index within (or at end of) readBuf.
my($readEnd) = 0;  # Index within (or at end of) readBuf.
my($needFlush) = 0;
my($needInitLzma) = 0;
my($needInitDic) = 0;
my($needInitState) = 0;
my($needInitProp) = 0;
my($lc) = 0;  # Configured in prop byte.
my($lp) = 0;  # Configured in prop byte.
my($pb) = 0;  # Configured in prop byte.
my($probs) = '';  # Probabilities for bit decoding.
  # The first READBUF_SIZE bytes is readBuf, then the LZMA_REQUIRED_INPUT_MAX bytes is tempBuf.
my($readBuf) = '';
  # Contains the uncompressed data.
  # *
  # * Array size is about 1.61 GB.
  # * We rely on virtual memory so that if we don't use the end of array for
  # * small files, then the operating system won't take the entire array away
  # * from other processes.
my($dic) = '';

sub UndefToMinus1($) { my $value = $_[0];
  return defined($value) ? $value : -1;
}


# ---
sub LzmaDec_WriteRem($) { my $dicLimit = $_[0];
  if ((((($remainLen) - (0)) & 0xffffffff) != 0) && lt32($remainLen, kMatchSpecLenStart)) {
    my $localLen = $remainLen;
    if (lt32($dicLimit - $dicPos, $localLen)) {
      $localLen = $dicLimit - $dicPos;
    }
    if ((((($checkDicSize) - (0)) & 0xffffffff) == 0) && (!lt32($localLen, $dicSize - $processedPos))) {
      $checkDicSize = $dicSize;
    }
    $processedPos += $localLen;
    $remainLen -= $localLen;
    while ((((($localLen) - (0)) & 0xffffffff) != 0)) {
      $localLen--;
      vec($dic, (($dicPos) & 0xffffffff), 8) = vec($dic, ((($dicPos - $rep0) + (lt32($dicPos, $rep0) ? $dicBufSize : 0)) & 0xffffffff), 8);
      $dicPos++;
    }
  }
}

# Modifies GLOBAL_VAR(bufCur) etc.
sub LzmaDec_DecodeReal2($$) { my($dicLimit, $bufLimit) = @_;
  my $pbMask = ((1) << ($pb)) - 1;
  my $lpMask = ((1) << ($lp)) - 1;
  goto do1; while (lt32($dicPos, $dicLimit) && lt32($bufCur, $bufLimit) && lt32($remainLen, kMatchSpecLenStart)) { do1:;
    my $dicLimit2 = (((($checkDicSize) - (0)) & 0xffffffff) == 0) && lt32($dicSize - $processedPos, $dicLimit - $dicPos) ? $dicPos + ($dicSize - $processedPos) : $dicLimit;
    my $localLen = 0;
    my $rangeLocal = $range;
    my $codeLocal = $code;
    goto do2; while (lt32($dicPos, $dicLimit2) && lt32($bufCur, $bufLimit)) { do2:;
      my $probIdx;
      my $bound;
      my $ttt;
      my $posState = $processedPos & $pbMask;

      $probIdx = IsMatch + ($state << (kNumPosBitsMax)) + $posState;
      $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
      if (lt32($codeLocal, $bound)) {
        my $symbol;
        $rangeLocal = $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt + (shr32((kBitModelTotal - $ttt), kNumMoveBits))) & 0xffff);
        $probIdx = Literal;
        if ((((($checkDicSize) - (0)) & 0xffffffff) != 0) || (((($processedPos) - (0)) & 0xffffffff) != 0)) {
          $probIdx += (LZMA_LIT_SIZE * ((($processedPos & $lpMask) << $lc) + shr32(vec($dic, ((((((($dicPos) - (0)) & 0xffffffff) == 0) ? $dicBufSize : $dicPos) - 1) & 0xffffffff), 8), (8 - $lc))));
        }
        if (lt32($state, kNumLitStates)) {
          $state -= (lt32($state, 4)) ? $state : 3;
          $symbol = 1;
          goto do3; while (lt32($symbol, 0x100)) { do3:;
            $ttt = vec($probs, (($probIdx + $symbol) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = (shr32($rangeLocal, kNumBitModelTotalBits)) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; vec($probs, (($probIdx + $symbol) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff); $symbol = ($symbol + $symbol); } else { $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx + $symbol) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff); $symbol = ($symbol + $symbol) + 1; }
          }
        } else {
          my $matchByte = vec($dic, ((($dicPos - $rep0) + (lt32($dicPos, $rep0) ? $dicBufSize : 0)) & 0xffffffff), 8);
          my $offs = 0x100;
          $state -= lt32($state, 10) ? 3 : 6;
          $symbol = 1;
          goto do4; while (lt32($symbol, 0x100)) { do4:;
            my $localBit;
            my $probLitIdx;
            $matchByte <<= 1;
            $localBit = ($matchByte & $offs);
            $probLitIdx = $probIdx + $offs + $localBit + $symbol;
            $ttt = vec($probs, (($probLitIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; vec($probs, (($probLitIdx) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff); $symbol = ($symbol + $symbol); $offs &= ~$localBit; } else { $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probLitIdx) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff); $symbol = ($symbol + $symbol) + 1; $offs &= $localBit; }
          }
        }
        vec($dic, (($dicPos++) & 0xffffffff), 8) = (($symbol) & 0xff);
        $processedPos++;
        next;
      } else {
        $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff);
        $probIdx = IsRep + $state;
        $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
        if (lt32($codeLocal, $bound)) {
          $rangeLocal = $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff);
          $state += kNumStates;
          $probIdx = LenCoder;
        } else {
          $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff);
          if ((((($checkDicSize) - (0)) & 0xffffffff) == 0) && (((($processedPos) - (0)) & 0xffffffff) == 0)) {
            return SZ_ERROR_DATA;
          }
          $probIdx = IsRepG0 + $state;
          $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
          if (lt32($codeLocal, $bound)) {
            $rangeLocal = $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff);
            $probIdx = IsRep0Long + ($state << (kNumPosBitsMax)) + $posState;
            $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
            if (lt32($codeLocal, $bound)) {
              $rangeLocal = $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff);
              vec($dic, (($dicPos) & 0xffffffff), 8) = vec($dic, ((($dicPos - $rep0) + (lt32($dicPos, $rep0) ? $dicBufSize : 0)) & 0xffffffff), 8);
              $dicPos++;
              $processedPos++;
              $state = lt32($state, kNumLitStates) ? 9 : 11;
              next;
            }
            $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff);
          } else {
            my $distance;
            $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff);
            $probIdx = IsRepG1 + $state;
            $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
            if (lt32($codeLocal, $bound)) {
              $rangeLocal = $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff);
              $distance = $rep1;
            } else {
              $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff);
              $probIdx = IsRepG2 + $state;
              $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
              if (lt32($codeLocal, $bound)) {
                $rangeLocal = $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff);
                $distance = $rep2;
              } else {
                $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff);
                $distance = $rep3;
                $rep3 = $rep2;
              }
              $rep2 = $rep1;
            }
            $rep1 = $rep0;
            $rep0 = $distance;
          }
          $state = lt32($state, kNumLitStates) ? 8 : 11;
          $probIdx = RepLenCoder;
        }
        {
          my $limitSub;
          my $offset;
          my $probLenIdx = $probIdx + LenChoice;
          $ttt = vec($probs, (($probLenIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
          if (lt32($codeLocal, $bound)) {
            $rangeLocal = $bound; vec($probs, (($probLenIdx) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff);
            $probLenIdx = $probIdx + LenLow + ($posState << (kLenNumLowBits));
            $offset = 0;
            $limitSub = ((1) << (kLenNumLowBits));
          } else {
            $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probLenIdx) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff);
            $probLenIdx = $probIdx + LenChoice2;
            $ttt = vec($probs, (($probLenIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
            if (lt32($codeLocal, $bound)) {
              $rangeLocal = $bound; vec($probs, (($probLenIdx) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff);
              $probLenIdx = $probIdx + LenMid + ($posState << (kLenNumMidBits));
              $offset = kLenNumLowSymbols;
              $limitSub = (1) << (kLenNumMidBits);
            } else {
              $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probLenIdx) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff);
              $probLenIdx = $probIdx + LenHigh;
              $offset = kLenNumLowSymbols + kLenNumMidSymbols;
              $limitSub = (1) << (kLenNumHighBits);
            }
          }
          {
            $localLen = 1;
            goto do5; while (lt32($localLen, $limitSub)) { do5:;
              { $ttt = vec($probs, ((($probLenIdx + $localLen)) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; vec($probs, ((($probLenIdx + $localLen)) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff); $localLen = ($localLen + $localLen); } else { $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, ((($probLenIdx + $localLen)) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff); $localLen = ($localLen + $localLen) + 1; } }
            }
            $localLen -= $limitSub;
          }
          $localLen += $offset;
        }

        if ((!lt32($state, kNumStates))) {
          my $distance;
          $probIdx = PosSlotCode + ((lt32($localLen, kNumLenToPosStates) ? $localLen : kNumLenToPosStates - 1) << (kNumPosSlotBits));
          {
            $distance = 1;
            goto do6; while (lt32($distance, (1 << 6))) { do6:;
              { $ttt = vec($probs, ((($probIdx + $distance)) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; vec($probs, ((($probIdx + $distance)) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff); $distance = ($distance + $distance); } else { $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, ((($probIdx + $distance)) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff); $distance = ($distance + $distance) + 1; } }
            }
            $distance -= (1 << 6);
          }
          if ((!lt32($distance, kStartPosModelIndex))) {
            my $posSlot = $distance;
            my $numDirectBits = shr32($distance, 1) - 1;
            $distance = (2 | ($distance & 1));
            if (lt32($posSlot, kEndPosModelIndex)) {
              $distance <<= $numDirectBits;
              $probIdx = SpecPos + $distance - $posSlot - 1;
              {
                my $mask = 1;
                my $localI = 1;
                goto do7; while (((((--$numDirectBits) - (0)) & 0xffffffff) != 0)) { do7:;
                  $ttt = vec($probs, (($probIdx + $localI) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; vec($probs, (($probIdx + $localI) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff); $localI = ($localI + $localI); } else { $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx + $localI) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff); $localI = ($localI + $localI) + 1; $distance |= $mask; }
                  $mask <<= 1;
                }
              }
            } else {
              $numDirectBits -= kNumAlignBits;
              goto do8; while (((((--$numDirectBits) - (0)) & 0xffffffff) != 0)) { do8:;
                my $localT;
                if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); }
                (($rangeLocal) = shr32($rangeLocal, 1));
                $codeLocal -= $rangeLocal;
                $localT = (0 - ((shr32($codeLocal, 31))));
                $distance = ($distance << 1) + ($localT + 1);
                $codeLocal += $rangeLocal & $localT;
              }
              $probIdx = Align;
              $distance <<= kNumAlignBits;
              {
                my $localI = 1;
                $ttt = vec($probs, (($probIdx + $localI) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; vec($probs, (($probIdx + $localI) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff); $localI = ($localI + $localI); } else { $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx + $localI) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff); $localI = ($localI + $localI) + 1; $distance |= 1; }
                $ttt = vec($probs, (($probIdx + $localI) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; vec($probs, (($probIdx + $localI) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff); $localI = ($localI + $localI); } else { $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx + $localI) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff); $localI = ($localI + $localI) + 1; $distance |= 2; }
                $ttt = vec($probs, (($probIdx + $localI) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; vec($probs, (($probIdx + $localI) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff); $localI = ($localI + $localI); } else { $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx + $localI) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff); $localI = ($localI + $localI) + 1; $distance |= 4; }
                $ttt = vec($probs, (($probIdx + $localI) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; vec($probs, (($probIdx + $localI) & 0xffffffff), 16) = (($ttt + shr32((kBitModelTotal - $ttt), kNumMoveBits)) & 0xffff); $localI = ($localI + $localI); } else { $rangeLocal -= $bound; $codeLocal -= $bound; vec($probs, (($probIdx + $localI) & 0xffffffff), 16) = (($ttt - shr32($ttt, kNumMoveBits)) & 0xffff); $localI = ($localI + $localI) + 1; $distance |= 8; }
              }
              if (((((~$distance) - (0)) & 0xffffffff) == 0)) {
                $localLen += kMatchSpecLenStart;
                $state -= kNumStates;
                last;
              }
            }
          }
          $rep3 = $rep2;
          $rep2 = $rep1;
          $rep1 = $rep0;
          $rep0 = $distance + 1;
          if ((((($checkDicSize) - (0)) & 0xffffffff) == 0)) {
            if ((!lt32($distance, $processedPos))) {
              return SZ_ERROR_DATA;
            }
          } else {
            if ((!lt32($distance, $checkDicSize))) {
              return SZ_ERROR_DATA;
            }
          }
          $state = lt32($state, kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
        }

        $localLen += kMatchMinLen;

        if ((((($dicLimit2) - ($dicPos)) & 0xffffffff) == 0)) {
          return SZ_ERROR_DATA;
        }
        {
          my $rem = $dicLimit2 - $dicPos;
          my $curLen = (lt32($rem, $localLen) ? $rem : $localLen);
          my $pos = ($dicPos - $rep0) + (lt32($dicPos, $rep0) ? $dicBufSize : 0);

          $processedPos += $curLen;

          $localLen -= $curLen;
          if ((!lt32($dicBufSize, $pos + $curLen))) {
            goto do9; while (((((--$curLen) - (0)) & 0xffffffff) != 0)) { do9:;
              # Here pos can be negative if 64-bit.
              vec($dic, (($dicPos++) & 0xffffffff), 8) = vec($dic, (($pos++) & 0xffffffff), 8);
            }
          } else {
            goto do10; while (((((--$curLen) - (0)) & 0xffffffff) != 0)) { do10:;
              vec($dic, (($dicPos++) & 0xffffffff), 8) = vec($dic, (($pos++) & 0xffffffff), 8);
              if ((((($pos) - ($dicBufSize)) & 0xffffffff) == 0)) { $pos = 0; }
            }
          }
        }
      }
    }
    if (lt32($rangeLocal, kTopValue)) { $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufCur++) & 0xffffffff), 8)); }
    $range = $rangeLocal;
    $code = $codeLocal;
    $remainLen = $localLen;
    if ((!lt32($processedPos, $dicSize))) {
      $checkDicSize = $dicSize;
    }
    LzmaDec_WriteRem($dicLimit);
  }

  if (lt32(kMatchSpecLenStart, $remainLen)) {
    $remainLen = kMatchSpecLenStart;
  }
  return SZ_OK;
}

sub LzmaDec_TryDummy($$) { my($bufDummyCur, $bufLimit) = @_;
  my $rangeLocal = $range;
  my $codeLocal = $code;
  my $stateLocal = $state;
  my $res;
  {
    my $probIdx;
    my $bound;
    my $ttt;
    my $posState = ($processedPos) & ((1 << $pb) - 1);

    $probIdx = IsMatch + ($stateLocal << (kNumPosBitsMax)) + $posState;
    $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
    if (lt32($codeLocal, $bound)) {
      $rangeLocal = $bound;
      $probIdx = Literal;
      if ((((($checkDicSize) - (0)) & 0xffffffff) != 0) || (((($processedPos) - (0)) & 0xffffffff) != 0)) {
        $probIdx += (LZMA_LIT_SIZE * (((($processedPos) & ((1 << ($lp)) - 1)) << $lc) + shr32(vec($dic, ((((((($dicPos) - (0)) & 0xffffffff) == 0) ? $dicBufSize : $dicPos) - 1) & 0xffffffff), 8), (8 - $lc))));
      }

      if (lt32($stateLocal, kNumLitStates)) {
        my $symbol = 1;
        goto do11; while (lt32($symbol, 0x100)) { do11:;
          $ttt = vec($probs, (($probIdx + $symbol) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; $symbol = ($symbol + $symbol); } else { $rangeLocal -= $bound; $codeLocal -= $bound; $symbol = ($symbol + $symbol) + 1; }
        }
      } else {
        my $matchByte = vec($dic, (($dicPos - $rep0 + (lt32($dicPos, $rep0) ? $dicBufSize : 0)) & 0xffffffff), 8);
        my $offs = 0x100;
        my $symbol = 1;
        goto do12; while (lt32($symbol, 0x100)) { do12:;
          my $localBit;
          my $probLitIdx;
          $matchByte <<= 1;
          $localBit = ($matchByte & $offs);
          $probLitIdx = $probIdx + $offs + $localBit + $symbol;
          $ttt = vec($probs, (($probLitIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; $symbol = ($symbol + $symbol); $offs &= ~$localBit; } else { $rangeLocal -= $bound; $codeLocal -= $bound; $symbol = ($symbol + $symbol) + 1; $offs &= $localBit; }
        }
      }
      $res = DUMMY_LIT;
    } else {
      my $localLen;
      $rangeLocal -= $bound; $codeLocal -= $bound;
      $probIdx = IsRep + $stateLocal;
      $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
      if (lt32($codeLocal, $bound)) {
        $rangeLocal = $bound;
        $stateLocal = 0;
        $probIdx = LenCoder;
        $res = DUMMY_MATCH;
      } else {
        $rangeLocal -= $bound; $codeLocal -= $bound;
        $res = DUMMY_REP;
        $probIdx = IsRepG0 + $stateLocal;
        $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
        if (lt32($codeLocal, $bound)) {
          $rangeLocal = $bound;
          $probIdx = IsRep0Long + ($stateLocal << (kNumPosBitsMax)) + $posState;
          $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
          if (lt32($codeLocal, $bound)) {
            $rangeLocal = $bound;
            if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); }
            return DUMMY_REP;
          } else {
            $rangeLocal -= $bound; $codeLocal -= $bound;
          }
        } else {
          $rangeLocal -= $bound; $codeLocal -= $bound;
          $probIdx = IsRepG1 + $stateLocal;
          $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
          if (lt32($codeLocal, $bound)) {
            $rangeLocal = $bound;
          } else {
            $rangeLocal -= $bound; $codeLocal -= $bound;
            $probIdx = IsRepG2 + $stateLocal;
            $ttt = vec($probs, (($probIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
            if (lt32($codeLocal, $bound)) {
              $rangeLocal = $bound;
            } else {
              $rangeLocal -= $bound; $codeLocal -= $bound;
            }
          }
        }
        $stateLocal = kNumStates;
        $probIdx = RepLenCoder;
      }
      {
        my $limitSub;
        my $offset;
        my $probLenIdx = $probIdx + LenChoice;
        $ttt = vec($probs, (($probLenIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
        if (lt32($codeLocal, $bound)) {
          $rangeLocal = $bound;
          $probLenIdx = $probIdx + LenLow + ($posState << (kLenNumLowBits));
          $offset = 0;
          $limitSub = (1) << (kLenNumLowBits);
        } else {
          $rangeLocal -= $bound; $codeLocal -= $bound;
          $probLenIdx = $probIdx + LenChoice2;
          $ttt = vec($probs, (($probLenIdx) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt;
          if (lt32($codeLocal, $bound)) {
            $rangeLocal = $bound;
            $probLenIdx = $probIdx + LenMid + ($posState << (kLenNumMidBits));
            $offset = kLenNumLowSymbols;
            $limitSub = (1) << (kLenNumMidBits);
          } else {
            $rangeLocal -= $bound; $codeLocal -= $bound;
            $probLenIdx = $probIdx + LenHigh;
            $offset = kLenNumLowSymbols + kLenNumMidSymbols;
            $limitSub = (1) << (kLenNumHighBits);
          }
        }
        {
          $localLen = 1;
          goto do13; while (lt32($localLen, $limitSub)) { do13:;
            $ttt = vec($probs, (($probLenIdx + $localLen) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; $localLen = ($localLen + $localLen); } else { $rangeLocal -= $bound; $codeLocal -= $bound; $localLen = ($localLen + $localLen) + 1; }
          }
          $localLen -= $limitSub;
        }
        $localLen += $offset;
      }

      if (lt32($stateLocal, 4)) {
        my $posSlot;
        $probIdx = PosSlotCode + ((lt32($localLen, kNumLenToPosStates) ? $localLen : kNumLenToPosStates - 1) << (kNumPosSlotBits));
        {
          $posSlot = 1;
          goto do14; while (lt32($posSlot, (1) << (kNumPosSlotBits))) { do14:;
            $ttt = vec($probs, (($probIdx + $posSlot) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; $posSlot = ($posSlot + $posSlot); } else { $rangeLocal -= $bound; $codeLocal -= $bound; $posSlot = ($posSlot + $posSlot) + 1; }
          }
          $posSlot -= (1) << (kNumPosSlotBits);
        }
        if ((!lt32($posSlot, kStartPosModelIndex))) {
          my $numDirectBits = shr32($posSlot, 1) - 1;
          if (lt32($posSlot, kEndPosModelIndex)) {
            $probIdx = SpecPos + ((2 | ($posSlot & 1)) << $numDirectBits) - $posSlot - 1;
          } else {
            $numDirectBits -= kNumAlignBits;
            goto do15; while (((((--$numDirectBits) - (0)) & 0xffffffff) != 0)) { do15:;
              if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); }
              (($rangeLocal) = shr32($rangeLocal, 1));
              $codeLocal -= $rangeLocal & (shr32(($codeLocal - $rangeLocal), 31) - 1);
            }
            $probIdx = Align;
            $numDirectBits = kNumAlignBits;
          }
          {
            my $localI = 1;
            goto do16; while (((((--$numDirectBits) - (0)) & 0xffffffff) != 0)) { do16:;
              $ttt = vec($probs, (($probIdx + $localI) & 0xffffffff), 16); if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); } $bound = shr32($rangeLocal, kNumBitModelTotalBits) * $ttt; if (lt32($codeLocal, $bound)) { $rangeLocal = $bound; $localI = ($localI + $localI); } else { $rangeLocal -= $bound; $codeLocal -= $bound; $localI = ($localI + $localI) + 1; }
            }
          }
        }
      }
    }
  }
  if (lt32($rangeLocal, kTopValue)) { if ((!lt32($bufDummyCur, $bufLimit))) { return DUMMY_ERROR; } $rangeLocal <<= 8; $codeLocal = ($codeLocal << 8) | (vec($readBuf, (($bufDummyCur++) & 0xffffffff), 8)); }
  return $res;
}

sub LzmaDec_InitDicAndState($$) { my($initDic, $initState) = @_;
  $needFlush = TRUE;
  $remainLen = 0;
  $tempBufSize = 0;

  if ($initDic) {
    $processedPos = 0;
    $checkDicSize = 0;
    $needInitLzma = TRUE;
  }
  if ($initState) {
    $needInitLzma = TRUE;
  }
}

# Decompress LZMA stream in
# * readBuf8[GLOBAL_VAR(readCur) : GLOBAL_VAR(readCur) + LOCAL_VAR(srcLen)].
# * On success (and on some errors as well), adds LOCAL_VAR(srcLen) to GLOBAL_VAR(readCur).
sub LzmaDec_DecodeToDic($) { my $srcLen = $_[0];
  # Index limit in GLOBAL_VAR(readBuf).
  my $decodeLimit = $readCur + $srcLen;
  LzmaDec_WriteRem($dicBufSize);

  while ((((($remainLen) - (kMatchSpecLenStart)) & 0xffffffff) != 0)) {
    my $checkEndMarkNow;

    if ($needFlush) {
      # Read 5 bytes (RC_INIT_SIZE) to tempBuf, first of which must be
      # * 0, initialize the range coder with the 4 bytes after the 0 byte.
      while (lt32($readCur, $decodeLimit) && lt32($tempBufSize, RC_INIT_SIZE)) {
        vec($readBuf, ((READBUF_SIZE + $tempBufSize++) & 0xffffffff), 8) = vec($readBuf, (($readCur++) & 0xffffffff), 8);
      }
      if (lt32($tempBufSize, RC_INIT_SIZE)) {
       on_needs_more_input:
        if ((((($decodeLimit) - ($readCur)) & 0xffffffff) != 0)) { return SZ_ERROR_NEEDS_MORE_INPUT_PARTIAL; }
        return SZ_ERROR_NEEDS_MORE_INPUT;
      }
      if (((((vec($readBuf, ((READBUF_SIZE) & 0xffffffff), 8)) - (0)) & 0xffffffff) != 0)) {
        return SZ_ERROR_DATA;
      }
      $code = ((vec($readBuf, ((READBUF_SIZE + 1) & 0xffffffff), 8)) << 24) | ((vec($readBuf, ((READBUF_SIZE + 2) & 0xffffffff), 8)) << 16) | ((vec($readBuf, ((READBUF_SIZE + 3) & 0xffffffff), 8)) << 8) | ((vec($readBuf, ((READBUF_SIZE + 4) & 0xffffffff), 8)));
      $range = 0xffffffff;
      $needFlush = FALSE;
      $tempBufSize = 0;
    }

    $checkEndMarkNow = FALSE;
    if ((!lt32($dicPos, $dicBufSize))) {
      if ((((($remainLen) - (0)) & 0xffffffff) == 0) && (((($code) - (0)) & 0xffffffff) == 0)) {
        if ((((($decodeLimit) - ($readCur)) & 0xffffffff) != 0)) { return SZ_ERROR_CHUNK_NOT_CONSUMED; }
        return SZ_OK  # MAYBE_FINISHED_WITHOUT_MARK
      }
      if ((((($remainLen) - (0)) & 0xffffffff) != 0)) {
        return SZ_ERROR_NOT_FINISHED;
      }
      $checkEndMarkNow = TRUE;
    }

    if ($needInitLzma) {
      my $numProbs = Literal + ((LZMA_LIT_SIZE) << ($lc + $lp));
      my $probIdx;
      for ($probIdx = 0; lt32($probIdx, $numProbs); $probIdx++) {
        vec($probs, (($probIdx) & 0xffffffff), 16) = shr32(kBitModelTotal, 1);
      }
      $rep0 = $rep1 = $rep2 = $rep3 = 1;
      $state = 0;
      $needInitLzma = FALSE;
    }

    if ((((($tempBufSize) - (0)) & 0xffffffff) == 0)) {
      my $bufLimit;
      if (lt32($decodeLimit - $readCur, LZMA_REQUIRED_INPUT_MAX) || $checkEndMarkNow) {
        my $dummyRes;
        $dummyRes = LzmaDec_TryDummy($readCur, $decodeLimit);
        if ((((($dummyRes) - (DUMMY_ERROR)) & 0xffffffff) == 0)) {
          # This line can be triggered by passing LOCAL_VAR(srcLen)=1 to LzmaDec_DecodeToDic.
          $tempBufSize = 0;
          while ((((($readCur) - ($decodeLimit)) & 0xffffffff) != 0)) {
            vec($readBuf, ((READBUF_SIZE + $tempBufSize++) & 0xffffffff), 8) = vec($readBuf, (($readCur++) & 0xffffffff), 8);
          }
          goto on_needs_more_input;
        }
        if ($checkEndMarkNow && (((($dummyRes) - (DUMMY_MATCH)) & 0xffffffff) != 0)) {
          return SZ_ERROR_NOT_FINISHED;
        }
        $bufLimit = $readCur;
      } else {
        $bufLimit = $decodeLimit - LZMA_REQUIRED_INPUT_MAX;
      }
      $bufCur = $readCur;
      if (((((LzmaDec_DecodeReal2($dicBufSize, $bufLimit)) - (0)) & 0xffffffff) != 0)) {
        return SZ_ERROR_DATA;
      }
      $readCur = $bufCur;
    } else {
      my $rem = $tempBufSize;
      my $lookAhead = 0;
      while (lt32($rem, LZMA_REQUIRED_INPUT_MAX) && lt32($lookAhead, $decodeLimit - $readCur)) {
        vec($readBuf, ((READBUF_SIZE + $rem++) & 0xffffffff), 8) = vec($readBuf, (($readCur + $lookAhead++) & 0xffffffff), 8);
      }
      $tempBufSize = $rem;
      if (lt32($rem, LZMA_REQUIRED_INPUT_MAX) || $checkEndMarkNow) {
        my $dummyRes;
        $dummyRes = LzmaDec_TryDummy(READBUF_SIZE, READBUF_SIZE + $rem);
        if ((((($dummyRes) - (DUMMY_ERROR)) & 0xffffffff) == 0)) {
          $readCur += $lookAhead;
          goto on_needs_more_input;
        }
        if ($checkEndMarkNow && (((($dummyRes) - (DUMMY_MATCH)) & 0xffffffff) != 0)) {
          return SZ_ERROR_NOT_FINISHED;
        }
      }
      # This line can be triggered by passing LOCAL_VAR(srcLen)=1 to LzmaDec_DecodeToDic.
      $bufCur = READBUF_SIZE;  # tempBuf.
      if (((((LzmaDec_DecodeReal2(0, READBUF_SIZE)) - (0)) & 0xffffffff) != 0)) {
        return SZ_ERROR_DATA;
      }
      $lookAhead -= $rem - ($bufCur - READBUF_SIZE);
      $readCur += $lookAhead;
      $tempBufSize = 0;
    }
  }
  if ((((($code) - (0)) & 0xffffffff) != 0)) { return SZ_ERROR_DATA; }
  return SZ_ERROR_FINISHED_WITH_MARK;
}

# Tries to preread r bytes to the read buffer. Returns the number of bytes
# * available in the read buffer. If smaller than r, that indicates EOF.
# *
# * Doesn't try to preread more than absolutely necessary, to avoid copies in
# * the future.
# *
# * Works only if LE(prereadPos, READBUF_SIZE).
sub Preread($) { my $prereadSize = $_[0];
  my $prereadPos = $readEnd - $readCur;
  if (lt32($prereadPos, $prereadSize)) {  # Not enough pending available.
    if (lt32(READBUF_SIZE - $readCur, $prereadSize)) {
      # If no room for LOCAL_VAR(prereadSize) bytes to the end, discard bytes from the beginning.
      for ($readEnd = 0; lt32($readEnd, $prereadPos); ++$readEnd) {
        vec($readBuf, (($readEnd) & 0xffffffff), 8) = vec($readBuf, (($readCur + $readEnd) & 0xffffffff), 8);
      }
      $readCur = 0;
    }
    while (lt32($prereadPos, $prereadSize)) {
      # Instead of (LOCAL_VAR(prereadSize) - LOCAL_VAR(prereadPos)) we could use (GLOBAL_VAR(readBuf) + READBUF_SIZE -
      # * GLOBAL_VAR(readEnd)) to read as much as the buffer has room for.
      my $got = UndefToMinus1(sysread(STDIN, $readBuf, ($prereadSize - $prereadPos), ($readEnd)));
      if (($got - 1) & 0x80000000) { last; }  # EOF or error on input.
      $readEnd += $got;
      $prereadPos += $got;
    }
  }
  return $prereadPos;
}

sub IgnoreVarint() {
  while ((!lt32(vec($readBuf, (($readCur++) & 0xffffffff), 8), 0x80))) {}
}

sub IgnoreZeroBytes($) { my $zeroByteCount = $_[0];
  for (; lt32(0, $zeroByteCount); --$zeroByteCount) {
    if (((((vec($readBuf, (($readCur++) & 0xffffffff), 8)) - (0)) & 0xffffffff) != 0)) {
      return SZ_ERROR_BAD_PADDING;
    }
  }
  return SZ_OK;
}

sub GetLE4($) { my $localReadPos = $_[0];
  return vec($readBuf, (($localReadPos) & 0xffffffff), 8) | vec($readBuf, (($localReadPos + 1) & 0xffffffff), 8) << 8 | vec($readBuf, (($localReadPos + 2) & 0xffffffff), 8) << 16 | vec($readBuf, (($localReadPos + 3) & 0xffffffff), 8) << 24;
}

# Expects GLOBAL_VAR(dicSize) be set already. Can be called before or after InitProp.
sub InitDecode() {
  # needInitProp will initialize it
  # SET_GLOBAL(lc, 106, =) SET_GLOBAL(pb, 108, =) SET_GLOBAL(lp, 110, =) 0;
  $dicBufSize = 0;  # We'll increment it later.
  $needInitDic = TRUE;
  $needInitState = TRUE;
  $needInitProp = TRUE;
  $dicPos = 0;
  LzmaDec_InitDicAndState(TRUE, TRUE);
}

sub InitProp($) { my $propByte = $_[0];
  if ((!lt32($propByte, 9 * 5 * 5))) { return SZ_ERROR_BAD_LCLPPB_PROP; }
  $lc = $propByte % 9;
  $propByte /= 9;
  $pb = $propByte / 5;
  $lp = $propByte % 5;
  if (lt32(LZMA2_LCLP_MAX, $lc + $lp)) { return SZ_ERROR_BAD_LCLPPB_PROP; }
  $needInitProp = FALSE;
  return SZ_OK;
}

# Writes uncompressed data dic[LOCAL_VAR(fromDicPos) : GLOBAL_VAR(dicPos)] to stdout.
sub WriteFrom($) { my $fromDicPos = $_[0];
  while ((((($fromDicPos) - ($dicPos)) & 0xffffffff) != 0)) {
    my $got = UndefToMinus1(syswrite(STDOUT, $dic, ($dicPos - $fromDicPos), ($fromDicPos)));
    if ($got & 0x80000000) { return SZ_ERROR_WRITE; }
    $fromDicPos += $got;
  }
  return SZ_OK;
}

# Reads .xz or .lzma data from stdin, writes uncompressed bytes to stdout,
# * uses GLOBAL_VAR(dic). It verifies some aspects of the file format (so it
# * can't be tricked to an infinite loop etc.), itdoesn't verify checksums
# * (e.g. CRC32).
sub DecompressXzOrLzma() {
  my $checksumSize;
  my $bhf;  # Block header flags
  my $res;

  # 12 for the stream header + 12 for the first block header + 6 for the
  # * first chunk header. empty.xz is 32 bytes.
  if (lt32(Preread(12 + 12 + 6), 12 + 12 + 6)) { return SZ_ERROR_INPUT_EOF; }
  # readBuf[6] is actually stream flags, should also be 0.
  if (((((vec($readBuf, ((0) & 0xffffffff), 8)) - (0xfd)) & 0xffffffff) == 0) && ((((vec($readBuf, ((1) & 0xffffffff), 8)) - (0x37)) & 0xffffffff) == 0) &&
      ((((vec($readBuf, ((2) & 0xffffffff), 8)) - (0x7a)) & 0xffffffff) == 0) && ((((vec($readBuf, ((3) & 0xffffffff), 8)) - (0x58)) & 0xffffffff) == 0) &&
      ((((vec($readBuf, ((4) & 0xffffffff), 8)) - (0x5a)) & 0xffffffff) == 0) && ((((vec($readBuf, ((5) & 0xffffffff), 8)) - (0)) & 0xffffffff) == 0) &&
      ((((vec($readBuf, ((6) & 0xffffffff), 8)) - (0)) & 0xffffffff) == 0)) {  # .xz: "\xFD""7zXZ\0"
  } elsif ((!lt32(225, vec($readBuf, (($readCur) & 0xffffffff), 8))) && ((((vec($readBuf, (($readCur + 13) & 0xffffffff), 8)) - (0)) & 0xffffffff) == 0) &&  # .lzma
        # High 4 bytes of uncompressed size.
        (((((($bhf = GetLE4($readCur + 9))) - (0)) & 0xffffffff) == 0) || (((($bhf) - (0xffffffff)) & 0xffffffff) == 0)) &&
        (!lt32(($dicSize = GetLE4($readCur + 1)), LZMA_DIC_MIN)) &&
        (!lt32(DIC_ARRAY_SIZE, $dicSize))) {
    # Based on https://svn.python.org/projects/external/xz-5.0.3/doc/lzma-file-format.txt
    my $readBufUS;
    my $srcLen;
    my $fromDicPos;
    InitDecode();
    # LZMA restricts LE(lc + lp, 4). LZMA requires LE(lc + lp, 12).
    # * We apply the LZMA2 restriction here (to save memory in
    # * GLOBAL_VAR(probs)), thus we are not able to extract some legitimate
    # * .lzma files.
    if (((((($res = InitProp(vec($readBuf, (($readCur) & 0xffffffff), 8)))) - (SZ_OK)) & 0xffffffff) != 0)) {
      return $res;
    }
    if ((((($bhf) - (0)) & 0xffffffff) == 0)) {
      $dicBufSize = $readBufUS = GetLE4($readCur + 5);
      if (lt32(DIC_ARRAY_SIZE, $readBufUS)) { return SZ_ERROR_MEM; }
    } else {
      $readBufUS = $bhf;  # max UInt32.
      $dicBufSize = DIC_ARRAY_SIZE;
    }
    $readCur += 13;  # Start decompressing the 0 byte.
    # TODO(pts): Limit on uncompressed size unless 8 bytes of -1 is
    # * specified.
    # Any Preread(...) amount starting from 1 works here, but higher values
    # * are faster.
    while (lt32(0, ($srcLen = Preread(READBUF_SIZE)))) {
      my $res;
      $fromDicPos = $dicPos;
      $res = LzmaDec_DecodeToDic($srcLen);
      if (lt32($readBufUS, $dicPos)) { $dicPos = $readBufUS; }
      if (((((($res = WriteFrom($fromDicPos))) - (SZ_OK)) & 0xffffffff) != 0)) { return $res; }
      if ((((($res) - (SZ_ERROR_FINISHED_WITH_MARK)) & 0xffffffff) == 0)) { last; }
      if ((((($res) - (SZ_ERROR_NEEDS_MORE_INPUT)) & 0xffffffff) != 0) && (((($res) - (SZ_OK)) & 0xffffffff) != 0)) { return $res; }
      if ((((($dicPos) - ($readBufUS)) & 0xffffffff) == 0)) { last; }
    }
    return SZ_OK;
  } else {
    return SZ_ERROR_BAD_MAGIC;
  }
  # Based on https://tukaani.org/xz/xz-file-format-1.0.4.txt
  $checksumSize = vec($readBuf, (($readCur + 7) & 0xffffffff), 8);
  if ((((($checksumSize) - (0)) & 0xffffffff) == 0)) {  # None
 $checksumSize = 1; }
  elsif ((((($checksumSize) - (1)) & 0xffffffff) == 0)) {  # CRC32
 $checksumSize = 4; }
  elsif ((((($checksumSize) - (4)) & 0xffffffff) == 0)) {  # CRC64, typical xz output.
 $checksumSize = 8; }
  else { return SZ_ERROR_BAD_CHECKSUM_TYPE; }
  # Also ignore the CRC32 after LOCAL_VAR(checksumSize).
  $readCur += 12;
  for (;;) {  # Next block.
    # We need it modulo 4, so a Byte is enough.
    my $blockSizePad = 3;
    my $bhs;
    my $bhs2;  # Block header size
    my $dicSizeProp;
    my $readAtBlock;
    $readAtBlock = $readCur;
    # Last block, index follows.
    if (((((($bhs = vec($readBuf, (($readCur++) & 0xffffffff), 8))) - (0)) & 0xffffffff) == 0)) { last; }
    # Block header size includes the LOCAL_VAR(bhs) field above and the CRC32 below.
    $bhs = ($bhs + 1) << 2;
    # Typically the Preread(12 + 12 + 6) above covers it.
    if (lt32(Preread($bhs), $bhs)) { return SZ_ERROR_INPUT_EOF; }
    $readAtBlock = $readCur;
    $bhf = vec($readBuf, (($readCur++) & 0xffffffff), 8);
    if (((((($bhf & 2)) - (0)) & 0xffffffff) != 0)) { return SZ_ERROR_UNSUPPORTED_FILTER_COUNT; }
    if (((((($bhf & 20)) - (0)) & 0xffffffff) != 0)) { return SZ_ERROR_BAD_BLOCK_FLAGS; }
    if ($bhf & 64) {  # Compressed size present.
      # Usually not present, just ignore it.
      IgnoreVarint();
    }
    if ($bhf & 128) {  # Uncompressed size present.
      # Usually not present, just ignore it.
      IgnoreVarint();
    }
    # This is actually a varint, but it's shorter to read it as a byte.
    if (((((vec($readBuf, (($readCur++) & 0xffffffff), 8)) - (FILTER_ID_LZMA2)) & 0xffffffff) != 0)) { return SZ_ERROR_UNSUPPORTED_FILTER_ID; }
    # This is actually a varint, but it's shorter to read it as a byte.
    if (((((vec($readBuf, (($readCur++) & 0xffffffff), 8)) - (1)) & 0xffffffff) != 0)) { return SZ_ERROR_UNSUPPORTED_FILTER_PROPERTIES_SIZE; }
    $dicSizeProp = vec($readBuf, (($readCur++) & 0xffffffff), 8);
    # Typical large dictionary sizes:
    # *
    # *  * 35: 805306368 bytes == 768 MiB
    # *  * 36: 1073741824 bytes == 1 GiB
    # *  * 37: 1610612736 bytes, largest supported by .xz
    # *  * 38: 2147483648 bytes == 2 GiB
    # *  * 39: 3221225472 bytes == 3 GiB
    # *  * 40: 4294967295 bytes, largest supported by .xz
    if (lt32(40, $dicSizeProp)) { return SZ_ERROR_BAD_DICTIONARY_SIZE; }
    # LZMA2 and .xz support it, we don't (for simpler memory management on
    # * 32-bit systems).
    if (lt32(37, $dicSizeProp)) { return SZ_ERROR_UNSUPPORTED_DICTIONARY_SIZE; }
    $dicSize = (((2) | (($dicSizeProp) & 1)) << (($dicSizeProp) / 2 + 11));
    $bhs2 = $readCur - $readAtBlock + 5;  # Won't overflow.
    if (lt32($bhs, $bhs2)) { return SZ_ERROR_BLOCK_HEADER_TOO_LONG; }
    if (((((($res = IgnoreZeroBytes($bhs - $bhs2))) - (SZ_OK)) & 0xffffffff) != 0)) { return $res; }
    $readCur += 4;  # Ignore CRC32.
    # Typically it's LOCAL_VAR(offset) 24, xz creates it by default, minimal.
    {  # Parse LZMA2 stream.
      # Based on https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm#LZMA2_format
      my $chunkUS;  # Uncompressed chunk sizes.
      my $chunkCS;  # Compressed chunk size.
      InitDecode();

      for (;;) {
        my $control;
        # Actually 2 bytes is enough to get to the index if everything is
        # * aligned and there is no block checksum.
        if (lt32(Preread(6), 6)) { return SZ_ERROR_INPUT_EOF; }
        $control = vec($readBuf, (($readCur) & 0xffffffff), 8);
        if ((((($control) - (0)) & 0xffffffff) == 0)) {
          ++$readCur;
          last;
        } elsif (lt32((($control - 3) & 0xff), 0x80 - 3)) {
          return SZ_ERROR_BAD_CHUNK_CONTROL_BYTE;
        }
        $chunkUS = (vec($readBuf, (($readCur + 1) & 0xffffffff), 8) << 8) + vec($readBuf, (($readCur + 2) & 0xffffffff), 8) + 1;
        if (lt32($control, 3)) {  # Uncompressed chunk.
          my $initDic = (((($control) - (1)) & 0xffffffff) == 0);
          $chunkCS = $chunkUS;
          $readCur += 3;
          # TODO(pts): Porting: TRUNCATE_TO_8BIT(LOCAL_VAR(blockSizePad)) for Python and other unlimited-integer-range languages.
          $blockSizePad -= 3;
          if ($initDic) {
            $needInitProp = $needInitState = TRUE;
            $needInitDic = FALSE;
          } elsif ($needInitDic) {
            return SZ_ERROR_DATA;
          }
          LzmaDec_InitDicAndState($initDic, FALSE);
        } else {  # LZMA chunk.
          my $mode = (shr32(($control), 5) & 3);
          my $initDic = (((($mode) - (3)) & 0xffffffff) == 0);
          my $initState = lt32(0, $mode);
          my $isProp = ((((($control & 64)) - (0)) & 0xffffffff) != 0);
          $chunkUS += ($control & 31) << 16;
          $chunkCS = (vec($readBuf, (($readCur + 3) & 0xffffffff), 8) << 8) + vec($readBuf, (($readCur + 4) & 0xffffffff), 8) + 1;
          if ($isProp) {
            if (((((($res = InitProp(vec($readBuf, (($readCur + 5) & 0xffffffff), 8)))) - (SZ_OK)) & 0xffffffff) != 0)) {
              return $res;
            }
            ++$readCur;
            --$blockSizePad;
          } else {
            if ($needInitProp) { return SZ_ERROR_MISSING_INITPROP; }
          }
          $readCur += 5;
          $blockSizePad -= 5;
          if ((!$initDic && $needInitDic) || (!$initState && $needInitState)) {
            return SZ_ERROR_DATA;
          }
          LzmaDec_InitDicAndState($initDic, $initState);
          $needInitDic = FALSE;
          $needInitState = FALSE;
        }
        $dicBufSize += $chunkUS;
        # Decompressed data too long, won't fit to GLOBAL_VAR(dic).
        if (lt32(DIC_ARRAY_SIZE, $dicBufSize)) { return SZ_ERROR_MEM; }
        # Read 6 extra bytes to optimize away a read(...) system call in
        # * the Prefetch(6) call in the next chunk header.
        if (lt32(Preread($chunkCS + 6), $chunkCS)) { return SZ_ERROR_INPUT_EOF; }
        if (lt32($control, 0x80)) {  # Uncompressed chunk.
          while ((((($dicPos) - ($dicBufSize)) & 0xffffffff) != 0)) {
            vec($dic, (($dicPos++) & 0xffffffff), 8) = vec($readBuf, (($readCur++) & 0xffffffff), 8);
          }
          if ((((($checkDicSize) - (0)) & 0xffffffff) == 0) && (!lt32($chunkUS, $dicSize - $processedPos))) {
            $checkDicSize = $dicSize;
          }
          $processedPos += $chunkUS;
        } else {  # Compressed chunk.
          # This call doesn't change GLOBAL_VAR(dicBufSize).
          if (((((($res = LzmaDec_DecodeToDic($chunkCS))) - (SZ_OK)) & 0xffffffff) != 0)) { return $res; }
        }
        if ((((($dicPos) - ($dicBufSize)) & 0xffffffff) != 0)) { return SZ_ERROR_BAD_DICPOS; }
        if (((((($res = WriteFrom($dicPos - $chunkUS))) - (SZ_OK)) & 0xffffffff) != 0)) { return $res; }
        $blockSizePad -= $chunkCS;
        # We can't discard decompressbuf[:GLOBAL_VAR(dicBufSize)] now,
        # * because we need it a dictionary in which subsequent calls to
        # * Lzma2Dec_DecodeToDic will look up backreferences.
      }
    }  # End of LZMA2 stream.
    # End of block.
    # 7 for padding4 and CRC32 + 12 for the next block header + 6 for the next
    # * chunk header.
    if (lt32(Preread(7 + 12 + 6), 7 + 12 + 6)) { return SZ_ERROR_INPUT_EOF; }
    # Ignore block padding.
    if (((((($res = IgnoreZeroBytes($blockSizePad & 3))) - (SZ_OK)) & 0xffffffff) != 0)) { return $res; }
    $readCur += $checksumSize;  # Ignore CRC32, CRC64 etc.
  }
  # The .xz input file continues with the index, which we ignore from here.
  return SZ_OK;
}
sub Decompress() {
  my $res;
  $probs = '';
  $readBuf = '';
  $dic = '';
  binmode(STDIN);
  binmode(STDOUT);
  $res = DecompressXzOrLzma();
  $probs = '';
  $readBuf = '';
  $dic = '';
  return $res;
}

exit(Decompress());
