#! /usr/bin/env perl
#
# muxzcat.pl: tiny .xz and .lzma decompression filter
# by pts@fazekas.hu at Thu Feb  7 00:19:59 CET 2019
#
# Usage: perl muxzcat.pl <input.xz >output.bin
#
# https://github.com/pts/muxzcat
#
# This is free software, GNU GPL >=2.0. There is NO WARRANTY. Use at your risk.
#
# This file was autogenerated by genpl.sh from muaxzcat.c.
#
BEGIN { $^W = 1 }
use integer;  # This is required.
use strict;   # Optional.
BEGIN {
die "fatal: your Perl does not support integer arithmetic\n" if 1 / 2 * 2;
die "fatal: your Perl cannot do 32-bit integer arithmetic\n" if
    abs(1 << 31 >> 31) != 1;
$_ = <<'ENDEVAL';

sub SZ_OK() { 0 }
sub SZ_ERROR_DATA() { 1 }
sub SZ_ERROR_MEM() { 2 }
sub SZ_ERROR_CRC() { 3 }
sub SZ_ERROR_UNSUPPORTED() { 4 }
sub SZ_ERROR_PARAM() { 5 }
sub SZ_ERROR_INPUT_EOF() { 6 }
sub SZ_ERROR_OUTPUT_EOF() { 7 }
sub SZ_ERROR_READ() { 8 }
sub SZ_ERROR_WRITE() { 9 }
sub SZ_ERROR_FINISHED_WITH_MARK() { 15 }
sub SZ_ERROR_NOT_FINISHED() { 16 }
sub SZ_ERROR_NEEDS_MORE_INPUT() { 17 }
sub SZ_ERROR_CHUNK_NOT_CONSUMED() { 18 }
sub SZ_ERROR_NEEDS_MORE_INPUT_PARTIAL() { 17 }
sub SZ_ERROR_BAD_MAGIC() { 51 }
sub SZ_ERROR_BAD_STREAM_FLAGS() { 52 }
sub SZ_ERROR_UNSUPPORTED_FILTER_COUNT() { 53 }
sub SZ_ERROR_BAD_BLOCK_FLAGS() { 54 }
sub SZ_ERROR_UNSUPPORTED_FILTER_ID() { 55 }
sub SZ_ERROR_UNSUPPORTED_FILTER_PROPERTIES_SIZE() { 56 }
sub SZ_ERROR_BAD_PADDING() { 57 }
sub SZ_ERROR_BLOCK_HEADER_TOO_LONG() { 58 }
sub SZ_ERROR_BAD_CHUNK_CONTROL_BYTE() { 59 }
sub SZ_ERROR_BAD_CHECKSUM_TYPE() { 60 }
sub SZ_ERROR_BAD_DICTIONARY_SIZE() { 61 }
sub SZ_ERROR_UNSUPPORTED_DICTIONARY_SIZE() { 62 }
sub SZ_ERROR_FEED_CHUNK() { 63 }
sub SZ_ERROR_NOT_FINISHED_WITH_MARK() { 64 }
sub SZ_ERROR_BAD_DICPOS() { 65 }
sub SZ_ERROR_MISSING_INITPROP() { 67 }
sub SZ_ERROR_BAD_LCLPPB_PROP() { 68 }
sub TRUE() { 1 }
sub FALSE() { 0 }
sub LZMA_REQUIRED_INPUT_MAX() { 20 }
sub LZMA_BASE_SIZE() { 1846 }
sub LZMA_LIT_SIZE() { 768 }
sub LZMA2_LCLP_MAX() { 4 }
sub LZMA2_MAX_NUM_PROBS() { 14134 }
sub DIC_ARRAY_SIZE() { 1610612736 }
sub RC_INIT_SIZE() { 5 }
sub kNumMoveBits() { 5 }
sub kNumTopBits() { 24 }
sub kNumBitModelTotalBits() { 11 }
sub kNumPosBitsMax() { 4 }
sub kLenNumLowBits() { 3 }
sub kLenNumMidBits() { 3 }
sub kLenNumHighBits() { 8 }
sub kNumStates() { 12 }
sub kNumLitStates() { 7 }
sub kStartPosModelIndex() { 4 }
sub kEndPosModelIndex() { 14 }
sub kNumPosSlotBits() { 6 }
sub kNumLenToPosStates() { 4 }
sub kNumAlignBits() { 4 }
sub kMatchMinLen() { 2 }
sub kTopValue() { 16777216 }
sub kBitModelTotal() { 2048 }
sub kNumPosStatesMax() { 16 }
sub kLenNumLowSymbols() { 8 }
sub kLenNumMidSymbols() { 8 }
sub kLenNumHighSymbols() { 256 }
sub LenChoice() { 0 }
sub LenChoice2() { 1 }
sub LenLow() { 2 }
sub LenMid() { 130 }
sub LenHigh() { 258 }
sub kNumLenProbs() { 514 }
sub kNumFullDistances() { 128 }
sub kAlignTableSize() { 16 }
sub kMatchSpecLenStart() { 274 }
sub IsMatch() { 0 }
sub IsRep() { 192 }
sub IsRepG0() { 204 }
sub IsRepG1() { 216 }
sub IsRepG2() { 228 }
sub IsRep0Long() { 240 }
sub PosSlotCode() { 432 }
sub SpecPos() { 688 }
sub Align() { 802 }
sub LenCoder() { 818 }
sub RepLenCoder() { 1332 }
sub Literal() { 1846 }
sub READBUF_SIZE() { (6 + 65536 + 6) }
sub LZMA_DIC_MIN() { (1 << 12) }
sub DUMMY_ERROR() { 0 }
sub DUMMY_LIT() { 1 }
sub DUMMY_MATCH() { 2 }
sub DUMMY_REP() { 3 }
sub FILTER_ID_LZMA2() { 0x21 }

# In Perl, BREAK and CONTINUE don't work (it silently goes to outer.
# * loops) in a do { ... } while (...) loop. So use `goto' instead of
# * BREAK and CONTINUE in such loops.
# *
# * !! Is a `for (;;) { ...; last unless ...; }' loop faster than a do-while
# *    loop in Perl?
# TODO(pts): Simplify doublings: e.g.
# * LOCAL_VAR(drSymbol) = (LOCAL_VAR(drSymbol) + LOCAL_VAR(drSymbol))
# * SET_LOCALB(distance, 251, =, (LOCAL_VAR(distance) + LOCAL_VAR(distance)));
# * SET_LOCALB(distance, 257, =, (LOCAL_VAR(distance) + LOCAL_VAR(distance)) + 1);
# The code doesn't have overflowing / /= % %=, so we don't create macros for these.
# These work only if IS_SMALL(x) and 0 <= y <= 31.
# These work only if IS_SMALL(x) && IS_SMALL(y).
# genpl.sh has the 32-bit (slow) and 64-bit (fast) implementations of
# * EQ0, NE0 and LT.
# ---
# Just check that it compiles.
# ---
# ---
# For LZMA streams, LE_SMALL(lc + lp, 8 + 4), LE 12.
# * For LZMA2 streams, LE_SMALL(lc + lp, 4).
# * Minimum value: 1846.
# * Maximum value for LZMA streams: 1846 + (768 << (8 + 4)) == 3147574.
# * Maximum value for LZMA2 streams: 1846 + (768 << 4) == 14134.
# * Memory usage of prob: sizeof(GET_ARY16(probs, 0)) * value == (2 or 4) * value bytes.
# #define LzmaProps_GetNumProbs(p) TRUNCATE_TO_32BIT(LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
my($bufCur) = 0;
my($dicSize) = 0;  # Configured in prop byte.
my($range) = 0;
my($code) = 0;
my($dicPos) = 0;
my($dicBufSize) = 0;
my($processedPos) = 0;
my($checkDicSize) = 0;
my($state) = 0;
my($rep0) = 0;
my($rep1) = 0;
my($rep2) = 0;
my($rep3) = 0;
my($remainLen) = 0;
my($tempBufSize) = 0;
my($readCur) = 0;  # Index within (or at end of) readBuf.
my($readEnd) = 0;  # Index within (or at end of) readBuf.
my($needFlush) = 0;
my($needInitLzma) = 0;
my($needInitDic) = 0;
my($needInitState) = 0;
my($needInitProp) = 0;
  # lc, lp and pb would fit into a byte, but i386 code is shorter as UInt32.
  # *
  # * Constraints:
  # *
  # * * (0 <= lc <= 8) by LZMA.
  # * * 0 <= lc <= 4 by LZMA2 and muxzcat.
  # * * 0 <= lp <= 4.
  # * * 0 <= pb <= 4.
  # * * (0 <= lc + lp == 8 + 4 <= 12) by LZMA.
  # * * 0 <= lc + lp <= 4 by LZMA2 and muxzcat.
my($lc) = 0;  # Configured in prop byte.
my($lp) = 0;  # Configured in prop byte.
my($pb) = 0;  # Configured in prop byte.
my($lcm8) = 0;  # Cached (8 - lc), for speed.
my($probs) = '';  # Probabilities for bit decoding.
  # The first READBUF_SIZE bytes is readBuf, then the
  # * LZMA_REQUIRED_INPUT_MAX bytes is tempBuf.
my($readBuf) = '';
  # Contains the uncompressed data.
  # *
  # * Array size is about 1.61 GB.
  # * We rely on virtual memory so that if we don't use the end of array for
  # * small files, then the operating system won't take the entire array away
  # * from other processes.
my($dic) = '';

sub UndefToMinus1($) { my $umValue = $_[0];
  return defined($umValue) ? $umValue : -1;
}


# ---
sub LzmaDec_WriteRem($) { my $wrDicLimit = $_[0];
  if ((($remainLen) != (0)) && (($remainLen) < (kMatchSpecLenStart))) {
    my $wrLen = $remainLen;
    if ((($wrDicLimit - $dicPos) < ($wrLen))) {
      $wrLen = $wrDicLimit - $dicPos;
    }
    if ((($checkDicSize) == (0)) && (($dicSize - $processedPos) <= ($wrLen))) {
      $checkDicSize = $dicSize;
    }
    $processedPos += $wrLen;
    $remainLen -= $wrLen;
    while ((($wrLen) != (0))) {
      $wrLen--;
      vec($dic, $dicPos, 8) = vec($dic, ($dicPos - $rep0) + ((($dicPos) < ($rep0)) ? $dicBufSize : 0), 8);
      $dicPos++;
    }
  }
}

# Modifies GLOBAL_VAR(bufCur) etc.
sub LzmaDec_DecodeReal2($$) { my($drDicLimit, $drBufLimit) = @_;
  my $pbMask = ((1) << ($pb)) - 1;
  my $lpMask = ((1) << ($lp)) - 1;
  my $drI;
  do {
    my $drDicLimit2 = (($checkDicSize) == (0)) && (($dicSize - $processedPos) < ($drDicLimit - $dicPos)) ? $dicPos + ($dicSize - $processedPos) : $drDicLimit;
    $remainLen = 0;
    do {
      my $drProbIdx;
      my $drBound;
      my $drTtt;  # 0 <= LOCAL_VAR(drTtt) <= kBitModelTotal.
      my $distance;
      my $drPosState = $processedPos & $pbMask;

      $drProbIdx = IsMatch + ($state << (kNumPosBitsMax)) + $drPosState;
      $drTtt = vec($probs, $drProbIdx, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt;
      if (LT[$code],[$drBound]) {
        my $drSymbol;
        $range = ($drBound); vec($probs, $drProbIdx, 16) = $drTtt + (((kBitModelTotal - $drTtt) >> (5)));
        $drProbIdx = Literal;
        if ((($checkDicSize) != (0)) || (($processedPos) != (0))) {
          $drProbIdx += (LZMA_LIT_SIZE * ((($processedPos & $lpMask) << $lc) + ((vec($dic, ((($dicPos) == (0)) ? $dicBufSize : $dicPos) - 1, 8)) >> ($lcm8))));
        }
        if ((($state) < (kNumLitStates))) {
          $state -= ((($state) < (4))) ? $state : 3;
          $drSymbol = 1;
          do {
            $drTtt = vec($probs, $drProbIdx + $drSymbol, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = (((($range) >> 11) & (0x7fffffff >> 10))) * $drTtt; if (LT[$code],[$drBound]) { $range = ($drBound); vec($probs, $drProbIdx + $drSymbol, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5)); $drSymbol = ($drSymbol + $drSymbol); } else { $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx + $drSymbol, 16) = $drTtt - (($drTtt) >> (5)); $drSymbol = ($drSymbol + $drSymbol) + 1; }
          } while ((($drSymbol) < (0x100)));
        } else {
          my $drMatchByte = vec($dic, ($dicPos - $rep0) + ((($dicPos) < ($rep0)) ? $dicBufSize : 0), 8);
          my $drMatchMask = 0x100;  # 0 or 0x100.
          $state -= (($state) < (10)) ? 3 : 6;
          $drSymbol = 1;
          do {
            my $drBit;
            my $drProbLitIdx;
            $drMatchByte <<= 1;
            $drBit = ($drMatchByte & $drMatchMask);
            $drProbLitIdx = $drProbIdx + $drMatchMask + $drBit + $drSymbol;
            $drTtt = vec($probs, $drProbLitIdx, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt; if (LT[$code],[$drBound]) { $range = ($drBound); vec($probs, $drProbLitIdx, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5)); $drSymbol = ($drSymbol + $drSymbol); $drMatchMask &= ~$drBit; } else { $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbLitIdx, 16) = $drTtt - (($drTtt) >> (5)); $drSymbol = ($drSymbol + $drSymbol) + 1; $drMatchMask &= $drBit; }
          } while ((($drSymbol) < (0x100)));
        }
        vec($dic, $dicPos++, 8) = $drSymbol;
        $processedPos++;
        goto continue_do2;  # CONTINUE;
      } else {
        $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx, 16) = $drTtt - (($drTtt) >> (5));
        $drProbIdx = IsRep + $state;
        $drTtt = vec($probs, $drProbIdx, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt;
        if (LT[$code],[$drBound]) {
          $range = ($drBound); vec($probs, $drProbIdx, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5));
          $state += kNumStates;
          $drProbIdx = LenCoder;
        } else {
          $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx, 16) = $drTtt - (($drTtt) >> (5));
          if ((($checkDicSize) == (0)) && (($processedPos) == (0))) {
            return SZ_ERROR_DATA;
          }
          $drProbIdx = IsRepG0 + $state;
          $drTtt = vec($probs, $drProbIdx, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt;
          if (LT[$code],[$drBound]) {
            $range = ($drBound); vec($probs, $drProbIdx, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5));
            $drProbIdx = IsRep0Long + ($state << (kNumPosBitsMax)) + $drPosState;
            $drTtt = vec($probs, $drProbIdx, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt;
            if (LT[$code],[$drBound]) {
              $range = ($drBound); vec($probs, $drProbIdx, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5));
              vec($dic, $dicPos, 8) = vec($dic, ($dicPos - $rep0) + ((($dicPos) < ($rep0)) ? $dicBufSize : 0), 8);
              $dicPos++;
              $processedPos++;
              $state = (($state) < (kNumLitStates)) ? 9 : 11;
              goto continue_do2;  # CONTINUE;
            }
            $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx, 16) = $drTtt - (($drTtt) >> (5));
          } else {
            $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx, 16) = $drTtt - (($drTtt) >> (5));
            $drProbIdx = IsRepG1 + $state;
            $drTtt = vec($probs, $drProbIdx, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt;
            if (LT[$code],[$drBound]) {
              $range = ($drBound); vec($probs, $drProbIdx, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5));
              $distance = $rep1;
            } else {
              $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx, 16) = $drTtt - (($drTtt) >> (5));
              $drProbIdx = IsRepG2 + $state;
              $drTtt = vec($probs, $drProbIdx, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt;
              if (LT[$code],[$drBound]) {
                $range = ($drBound); vec($probs, $drProbIdx, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5));
                $distance = $rep2;
              } else {
                $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx, 16) = $drTtt - (($drTtt) >> (5));
                $distance = $rep3;
                $rep3 = $rep2;
              }
              $rep2 = $rep1;
            }
            $rep1 = $rep0;
            $rep0 = $distance;
          }
          $state = (($state) < (kNumLitStates)) ? 8 : 11;
          $drProbIdx = RepLenCoder;
        }
        {
          my $drLimitSub;
          my $drOffset;
          my $drProbLenIdx = $drProbIdx + LenChoice;
          $drTtt = vec($probs, $drProbLenIdx, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt;
          if (LT[$code],[$drBound]) {
            $range = ($drBound); vec($probs, $drProbLenIdx, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5));
            $drProbLenIdx = $drProbIdx + LenLow + ($drPosState << (kLenNumLowBits));
            $drOffset = 0;
            $drLimitSub = ((1) << (kLenNumLowBits));
          } else {
            $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbLenIdx, 16) = $drTtt - (($drTtt) >> (5));
            $drProbLenIdx = $drProbIdx + LenChoice2;
            $drTtt = vec($probs, $drProbLenIdx, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt;
            if (LT[$code],[$drBound]) {
              $range = ($drBound); vec($probs, $drProbLenIdx, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5));
              $drProbLenIdx = $drProbIdx + LenMid + ($drPosState << (kLenNumMidBits));
              $drOffset = kLenNumLowSymbols;
              $drLimitSub = (1) << (kLenNumMidBits);
            } else {
              $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbLenIdx, 16) = $drTtt - (($drTtt) >> (5));
              $drProbLenIdx = $drProbIdx + LenHigh;
              $drOffset = kLenNumLowSymbols + kLenNumMidSymbols;
              $drLimitSub = (1) << (kLenNumHighBits);
            }
          }
          {
            $remainLen = (1);
            do {
              { $drTtt = vec($probs, ($drProbLenIdx + $remainLen), 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt; if (LT[$code],[$drBound]) { $range = ($drBound); vec($probs, ($drProbLenIdx + $remainLen), 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5)); $remainLen = (($remainLen + $remainLen)); } else { $range -= ($drBound); $code -= ($drBound); vec($probs, ($drProbLenIdx + $remainLen), 16) = $drTtt - (($drTtt) >> (5)); $remainLen = (($remainLen + $remainLen) + 1); } }
            } while ((($remainLen) < ($drLimitSub)));
            $remainLen -= ($drLimitSub);
          }
          $remainLen += ($drOffset);
        }

        if ((($state) >= (kNumStates))) {
          $drProbIdx = PosSlotCode + (((($remainLen) < (kNumLenToPosStates)) ? $remainLen : kNumLenToPosStates - 1) << (kNumPosSlotBits));
          {
            $distance = 1;
            do {
              { $drTtt = vec($probs, ($drProbIdx + $distance), 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt; if (LT[$code],[$drBound]) { $range = ($drBound); vec($probs, ($drProbIdx + $distance), 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5)); $distance = ($distance + $distance); } else { $range -= ($drBound); $code -= ($drBound); vec($probs, ($drProbIdx + $distance), 16) = $drTtt - (($drTtt) >> (5)); $distance = ($distance + $distance) + 1; } }
            } while ((($distance) < ((1 << 6))));
            $distance -= (1 << 6);
          }
          if ((($distance) >= (kStartPosModelIndex))) {
            my $drPosSlot = $distance;
            my $drDirectBitCount = (($distance) >> (1)) - 1;
            $distance = (2 | ($distance & 1));
            if ((($drPosSlot) < (kEndPosModelIndex))) {
              $distance <<= $drDirectBitCount;
              $drProbIdx = SpecPos + $distance - $drPosSlot - 1;
              {
                my $mask = 1;
                $drI = 1;
                do {
                  $drTtt = vec($probs, $drProbIdx + $drI, 16); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt; if (LT[$code],[$drBound]) { $range = ($drBound); vec($probs, $drProbIdx + $drI, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5)); $drI = ($drI + $drI); } else { $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx + $drI, 16) = $drTtt - (($drTtt) >> (5)); $drI = ($drI + $drI) + 1; $distance |= $mask; }
                  $mask <<= 1;
                } while (((--$drDirectBitCount) != (0)));
              }
            } else {
              $drDirectBitCount -= kNumAlignBits;
              do {
                if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); }
                # Here GLOBAL_VAR(range) can be non-small, so we can't use SHR_SMALLX instead of SHR1.
                $range = (((($range) >> 1) & 0x7fffffff));
                if (($code - $range) & 0x80000000) {
                  $distance <<= 1;
                } else {
                  $code -= ($range);
                  # This won't be faster in Perl: <<= 1, ++
                  $distance = ($distance << 1) + 1;
                }
              } while (((--$drDirectBitCount) != (0)));
              $drProbIdx = Align;
              $distance <<= kNumAlignBits;
              {
                $drI = 1;
                $drTtt = vec($probs, $drProbIdx + $drI, 16); do {} while (0 && (((($drTtt) & ~0x7fffffff) == 0) && (($drTtt) <= (kBitModelTotal)))); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt; if (LT[$code],[$drBound]) { $range = ($drBound); vec($probs, $drProbIdx + $drI, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5)); $drI = ($drI + $drI); } else { $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx + $drI, 16) = $drTtt - (($drTtt) >> (5)); $drI = ($drI + $drI) + 1; $distance |= 1; }
                $drTtt = vec($probs, $drProbIdx + $drI, 16); do {} while (0 && (((($drTtt) & ~0x7fffffff) == 0) && (($drTtt) <= (kBitModelTotal)))); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt; if (LT[$code],[$drBound]) { $range = ($drBound); vec($probs, $drProbIdx + $drI, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5)); $drI = ($drI + $drI); } else { $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx + $drI, 16) = $drTtt - (($drTtt) >> (5)); $drI = ($drI + $drI) + 1; $distance |= 2; }
                $drTtt = vec($probs, $drProbIdx + $drI, 16); do {} while (0 && (((($drTtt) & ~0x7fffffff) == 0) && (($drTtt) <= (kBitModelTotal)))); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt; if (LT[$code],[$drBound]) { $range = ($drBound); vec($probs, $drProbIdx + $drI, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5)); $drI = ($drI + $drI); } else { $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx + $drI, 16) = $drTtt - (($drTtt) >> (5)); $drI = ($drI + $drI) + 1; $distance |= 4; }
                $drTtt = vec($probs, $drProbIdx + $drI, 16); do {} while (0 && (((($drTtt) & ~0x7fffffff) == 0) && (($drTtt) <= (kBitModelTotal)))); if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); } $drBound = ((($range) >> 11) & (0x7fffffff >> 10)) * $drTtt; if (LT[$code],[$drBound]) { $range = ($drBound); vec($probs, $drProbIdx + $drI, 16) = $drTtt + ((kBitModelTotal - $drTtt) >> (5)); $drI = ($drI + $drI); } else { $range -= ($drBound); $code -= ($drBound); vec($probs, $drProbIdx + $drI, 16) = $drTtt - (($drTtt) >> (5)); $drI = ($drI + $drI) + 1; $distance |= 8; }
              }
              if (EQ0[~$distance]) {
                $remainLen += (kMatchSpecLenStart);
                $state -= kNumStates;
                goto break_do2;  # BREAK;
              }
            }
          }
          # TODO(pts): Do the 2 instances of SZ_ERROR_DATA below also check this?
          $rep3 = $rep2;
          $rep2 = $rep1;
          $rep1 = $rep0;
          $rep0 = $distance + 1;
          if ((($checkDicSize) == (0))) {
            if ((($distance) >= ($processedPos))) {
              return SZ_ERROR_DATA;
            }
          } else {
            if ((($distance) >= ($checkDicSize))) {
              return SZ_ERROR_DATA;
            }
          }
          $state = (($state) < (kNumStates + kNumLitStates)) ? kNumLitStates : kNumLitStates + 3;
        }

        $remainLen += (kMatchMinLen);

        if ((($drDicLimit2) == ($dicPos))) {
          return SZ_ERROR_DATA;
        }
        {
          my $drRem = $drDicLimit2 - $dicPos;
          my $curLen = ((($drRem) < ($remainLen)) ? $drRem : $remainLen);
          my $pos = ($dicPos - $rep0) + ((($dicPos) < ($rep0)) ? $dicBufSize : 0);

          $processedPos += $curLen;

          $remainLen -= ($curLen);
          if ((($pos + $curLen) <= ($dicBufSize))) {
            do {
              # Here pos can be negative if 64-bit.
              vec($dic, $dicPos++, 8) = vec($dic, $pos++, 8);
            } while (((--$curLen) != (0)));
          } else {
            do {
              vec($dic, $dicPos++, 8) = vec($dic, $pos++, 8);
              if ((($pos) == ($dicBufSize))) { $pos = 0; }
            } while (((--$curLen) != (0)));
          }
        }
      }
     continue_do2:;
    } while ((($dicPos) < ($drDicLimit2)) && (($bufCur) < ($drBufLimit)));
    break_do2:;
    if (LTX[$range],[kTopValue]) { $range <<= (8); $code = (($code << 8) | (vec($readBuf, $bufCur++, 8))); }
    if ((($processedPos) >= ($dicSize))) {
      $checkDicSize = $dicSize;
    }
    LzmaDec_WriteRem($drDicLimit);
  } while ((($dicPos) < ($drDicLimit)) && (($bufCur) < ($drBufLimit)) && (($remainLen) < (kMatchSpecLenStart)));

  if ((($remainLen) > (kMatchSpecLenStart))) {
    $remainLen = kMatchSpecLenStart;
  }
  return SZ_OK;
}

sub LzmaDec_TryDummy($$) { my($tdCur, $tdBufLimit) = @_;
  my $tdRange = $range;
  my $tdCode = $code;
  my $tdState = $state;
  my $tdRes;
  my $tdProbIdx;
  my $tdBound;
  my $tdTtt;
  my $tdPosState = ($processedPos) & ((1 << $pb) - 1);
  $tdProbIdx = IsMatch + ($tdState << (kNumPosBitsMax)) + $tdPosState;
  $tdTtt = vec($probs, $tdProbIdx, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt;
  if (LT[$tdCode],[$tdBound]) {
    my $tdSymbol = 1;
    $tdRange = $tdBound;
    $tdProbIdx = Literal;
    if ((($checkDicSize) != (0)) || (($processedPos) != (0))) {
      $tdProbIdx += (LZMA_LIT_SIZE * (((($processedPos) & ((1 << ($lp)) - 1)) << $lc) + ((vec($dic, ((($dicPos) == (0)) ? $dicBufSize : $dicPos) - 1, 8)) >> ($lcm8))));
    }

    if ((($tdState) < (kNumLitStates))) {
      do {
        $tdTtt = vec($probs, $tdProbIdx + $tdSymbol, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt; if (LT[$tdCode],[$tdBound]) { $tdRange = $tdBound; $tdSymbol = ($tdSymbol + $tdSymbol); } else { $tdRange -= $tdBound; $tdCode -= $tdBound; $tdSymbol = ($tdSymbol + $tdSymbol) + 1; }
      } while ((($tdSymbol) < (0x100)));
    } else {
      my $tdMatchByte = vec($dic, $dicPos - $rep0 + ((($dicPos) < ($rep0)) ? $dicBufSize : 0), 8);
      my $tdMatchMask = 0x100;  # 0 or 0x100.
      do {
        my $tdBit;
        my $tdProbLitIdx;
        $tdMatchByte <<= 1;
        $tdBit = ($tdMatchByte & $tdMatchMask);
        $tdProbLitIdx = $tdProbIdx + $tdMatchMask + $tdBit + $tdSymbol;
        $tdTtt = vec($probs, $tdProbLitIdx, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt; if (LT[$tdCode],[$tdBound]) { $tdRange = $tdBound; $tdSymbol = ($tdSymbol + $tdSymbol); $tdMatchMask &= ~$tdBit; } else { $tdRange -= $tdBound; $tdCode -= $tdBound; $tdSymbol = ($tdSymbol + $tdSymbol) + 1; $tdMatchMask &= $tdBit; }
      } while ((($tdSymbol) < (0x100)));
    }
    $tdRes = DUMMY_LIT;
  } else {
    my $tdLen;
    $tdRange -= $tdBound; $tdCode -= $tdBound;
    $tdProbIdx = IsRep + $tdState;
    $tdTtt = vec($probs, $tdProbIdx, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt;
    if (LT[$tdCode],[$tdBound]) {
      $tdRange = $tdBound;
      $tdState = 0;
      $tdProbIdx = LenCoder;
      $tdRes = DUMMY_MATCH;
    } else {
      $tdRange -= $tdBound; $tdCode -= $tdBound;
      $tdRes = DUMMY_REP;
      $tdProbIdx = IsRepG0 + $tdState;
      $tdTtt = vec($probs, $tdProbIdx, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt;
      if (LT[$tdCode],[$tdBound]) {
        $tdRange = $tdBound;
        $tdProbIdx = IsRep0Long + ($tdState << (kNumPosBitsMax)) + $tdPosState;
        $tdTtt = vec($probs, $tdProbIdx, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt;
        if (LT[$tdCode],[$tdBound]) {
          $tdRange = $tdBound;
          if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); }
          return DUMMY_REP;
        } else {
          $tdRange -= $tdBound; $tdCode -= $tdBound;
        }
      } else {
        $tdRange -= $tdBound; $tdCode -= $tdBound;
        $tdProbIdx = IsRepG1 + $tdState;
        $tdTtt = vec($probs, $tdProbIdx, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt;
        if (LT[$tdCode],[$tdBound]) {
          $tdRange = $tdBound;
        } else {
          $tdRange -= $tdBound; $tdCode -= $tdBound;
          $tdProbIdx = IsRepG2 + $tdState;
          $tdTtt = vec($probs, $tdProbIdx, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt;
          if (LT[$tdCode],[$tdBound]) {
            $tdRange = $tdBound;
          } else {
            $tdRange -= $tdBound; $tdCode -= $tdBound;
          }
        }
      }
      $tdState = kNumStates;
      $tdProbIdx = RepLenCoder;
    }
    {
      my $tdLimitSub;
      my $tdOffset;
      my $tdProbLenIdx = $tdProbIdx + LenChoice;
      $tdTtt = vec($probs, $tdProbLenIdx, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt;
      if (LT[$tdCode],[$tdBound]) {
        $tdRange = $tdBound;
        $tdProbLenIdx = $tdProbIdx + LenLow + ($tdPosState << (kLenNumLowBits));
        $tdOffset = 0;
        $tdLimitSub = (1) << (kLenNumLowBits);
      } else {
        $tdRange -= $tdBound; $tdCode -= $tdBound;
        $tdProbLenIdx = $tdProbIdx + LenChoice2;
        $tdTtt = vec($probs, $tdProbLenIdx, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt;
        if (LT[$tdCode],[$tdBound]) {
          $tdRange = $tdBound;
          $tdProbLenIdx = $tdProbIdx + LenMid + ($tdPosState << (kLenNumMidBits));
          $tdOffset = kLenNumLowSymbols;
          $tdLimitSub = (1) << (kLenNumMidBits);
        } else {
          $tdRange -= $tdBound; $tdCode -= $tdBound;
          $tdProbLenIdx = $tdProbIdx + LenHigh;
          $tdOffset = kLenNumLowSymbols + kLenNumMidSymbols;
          $tdLimitSub = (1) << (kLenNumHighBits);
        }
      }
      {
        $tdLen = 1;
        do {
          $tdTtt = vec($probs, $tdProbLenIdx + $tdLen, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt; if (LT[$tdCode],[$tdBound]) { $tdRange = $tdBound; $tdLen = ($tdLen + $tdLen); } else { $tdRange -= $tdBound; $tdCode -= $tdBound; $tdLen = ($tdLen + $tdLen) + 1; }
        } while ((($tdLen) < ($tdLimitSub)));
        $tdLen -= $tdLimitSub;
      }
      $tdLen += $tdOffset;
    }

    if ((($tdState) < (4))) {
      my $tdPosSlot;
      $tdProbIdx = PosSlotCode + (((($tdLen) < (kNumLenToPosStates)) ? $tdLen : kNumLenToPosStates - 1) << (kNumPosSlotBits));
      {
        $tdPosSlot = 1;
        do {
          $tdTtt = vec($probs, $tdProbIdx + $tdPosSlot, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt; if (LT[$tdCode],[$tdBound]) { $tdRange = $tdBound; $tdPosSlot = ($tdPosSlot + $tdPosSlot); } else { $tdRange -= $tdBound; $tdCode -= $tdBound; $tdPosSlot = ($tdPosSlot + $tdPosSlot) + 1; }
        } while ((($tdPosSlot) < ((1) << (kNumPosSlotBits))));
        $tdPosSlot -= (1) << (kNumPosSlotBits);
      }
      # Small enough for SHR_SMALLX(LOCAL_VAR(tdPosSlot), ...).
      if ((($tdPosSlot) >= (kStartPosModelIndex))) {
        my $tdDirectBitCount = (($tdPosSlot) >> (1)) - 1;
        if ((($tdPosSlot) < (kEndPosModelIndex))) {
          $tdProbIdx = SpecPos + ((2 | ($tdPosSlot & 1)) << $tdDirectBitCount) - $tdPosSlot - 1;
        } else {
          $tdDirectBitCount -= kNumAlignBits;
          do {
            if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); }
            $tdRange = ((($tdRange) >> 1) & 0x7fffffff);
            if (!(($tdCode - $tdRange) & 0x80000000)) {
              $tdCode -= $tdRange;
            }
          } while (((--$tdDirectBitCount) != (0)));
          $tdProbIdx = Align;
          $tdDirectBitCount = kNumAlignBits;
        }
        {
          my $tdI = 1;
          do {
            $tdTtt = vec($probs, $tdProbIdx + $tdI, 16); if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); } $tdBound = ((($tdRange) >> 11) & (0x7fffffff >> 10)) * $tdTtt; if (LT[$tdCode],[$tdBound]) { $tdRange = $tdBound; $tdI = ($tdI + $tdI); } else { $tdRange -= $tdBound; $tdCode -= $tdBound; $tdI = ($tdI + $tdI) + 1; }
          } while (((--$tdDirectBitCount) != (0)));
        }
      }
    }
  }
  if (LTX[$tdRange],[kTopValue]) { if ((($tdCur) >= ($tdBufLimit))) { return DUMMY_ERROR; } $tdRange <<= 8; $tdCode = ($tdCode << 8) | (vec($readBuf, $tdCur++, 8)); }
  return $tdRes;
}

sub LzmaDec_InitDicAndState($$) { my($idInitDic, $idInitState) = @_;
  $needFlush = TRUE;
  $remainLen = 0;
  $tempBufSize = 0;

  if ($idInitDic) {
    $processedPos = 0;
    $checkDicSize = 0;
    $needInitLzma = TRUE;
  }
  if ($idInitState) {
    $needInitLzma = TRUE;
  }
}

# Decompress LZMA stream in
# * readBuf8[GLOBAL_VAR(readCur) : GLOBAL_VAR(readCur) + LOCAL_VAR(ddSrcLen)].
# * On success (and on some errors as well), adds LOCAL_VAR(ddSrcLen) to GLOBAL_VAR(readCur).
sub LzmaDec_DecodeToDic($) { my $ddSrcLen = $_[0];
  # Index limit in GLOBAL_VAR(readBuf).
  my $decodeLimit = $readCur + $ddSrcLen;
  my $checkEndMarkNow;
  my $dummyRes;
  LzmaDec_WriteRem($dicBufSize);

  while ((($remainLen) != (kMatchSpecLenStart))) {

    if ($needFlush) {
      # Read 5 bytes (RC_INIT_SIZE) to tempBuf, first of which must be
      # * 0, initialize the range coder with the 4 bytes after the 0 byte.
      while ((($decodeLimit) > ($readCur)) && (($tempBufSize) < (RC_INIT_SIZE))) {
        vec($readBuf, READBUF_SIZE + $tempBufSize++, 8) = vec($readBuf, $readCur++, 8);
      }
      if ((($tempBufSize) < (RC_INIT_SIZE))) {
       on_needs_more_input:
        if ((($readCur) != ($decodeLimit))) { return SZ_ERROR_NEEDS_MORE_INPUT_PARTIAL; }
        return SZ_ERROR_NEEDS_MORE_INPUT;
      }
      if (((vec($readBuf, READBUF_SIZE, 8)) != (0))) {
        return SZ_ERROR_DATA;
      }
      $code = ((vec($readBuf, READBUF_SIZE + 1, 8)) << 24) | ((vec($readBuf, READBUF_SIZE + 2, 8)) << 16) | ((vec($readBuf, READBUF_SIZE + 3, 8)) << 8) | ((vec($readBuf, READBUF_SIZE + 4, 8)));
      $range = 0xffffffff;
      $needFlush = FALSE;
      $tempBufSize = 0;
    }

    $checkEndMarkNow = FALSE;
    if ((($dicPos) >= ($dicBufSize))) {
      if ((($remainLen) == (0)) && EQ0[$code]) {
        if ((($readCur) != ($decodeLimit))) { return SZ_ERROR_CHUNK_NOT_CONSUMED; }
        return SZ_OK  # MAYBE_FINISHED_WITHOUT_MARK
      }
      if ((($remainLen) != (0))) {
        return SZ_ERROR_NOT_FINISHED;
      }
      $checkEndMarkNow = TRUE;
    }

    if ($needInitLzma) {
      my $numProbs = Literal + ((LZMA_LIT_SIZE) << ($lc + $lp));
      my $ddProbIdx;
      for ($ddProbIdx = 0; (($ddProbIdx) < ($numProbs)); $ddProbIdx++) {
        vec($probs, $ddProbIdx, 16) = ((kBitModelTotal) >> (1));
      }
      $rep0 = $rep1 = $rep2 = $rep3 = 1;
      $state = 0;
      $needInitLzma = FALSE;
    }

    if ((($tempBufSize) == (0))) {
      my $bufLimit;
      if ((($decodeLimit - $readCur) < (LZMA_REQUIRED_INPUT_MAX)) || $checkEndMarkNow) {
        $dummyRes = LzmaDec_TryDummy($readCur, $decodeLimit);
        if ((($dummyRes) == (DUMMY_ERROR))) {
          # This line can be triggered by passing LOCAL_VAR(ddSrcLen)=1 to LzmaDec_DecodeToDic.
          $tempBufSize = 0;
          while ((($readCur) != ($decodeLimit))) {
            vec($readBuf, READBUF_SIZE + $tempBufSize++, 8) = vec($readBuf, $readCur++, 8);
          }
          goto on_needs_more_input;
        }
        if ($checkEndMarkNow && (($dummyRes) != (DUMMY_MATCH))) {
          return SZ_ERROR_NOT_FINISHED;
        }
        $bufLimit = $readCur;
      } else {
        $bufLimit = $decodeLimit - LZMA_REQUIRED_INPUT_MAX;
      }
      $bufCur = $readCur;
      if (((LzmaDec_DecodeReal2($dicBufSize, $bufLimit)) != (SZ_OK))) {
        return SZ_ERROR_DATA;
      }
      $readCur = $bufCur;
    } else {
      my $ddRem = $tempBufSize;
      my $lookAhead = 0;
      while ((($ddRem) < (LZMA_REQUIRED_INPUT_MAX)) && (($lookAhead) < ($decodeLimit - $readCur))) {
        vec($readBuf, READBUF_SIZE + $ddRem++, 8) = vec($readBuf, $readCur + $lookAhead++, 8);
      }
      $tempBufSize = $ddRem;
      if ((($ddRem) < (LZMA_REQUIRED_INPUT_MAX)) || $checkEndMarkNow) {
        $dummyRes = LzmaDec_TryDummy(READBUF_SIZE, READBUF_SIZE + $ddRem);
        if ((($dummyRes) == (DUMMY_ERROR))) {
          $readCur += $lookAhead;
          goto on_needs_more_input;
        }
        if ($checkEndMarkNow && (($dummyRes) != (DUMMY_MATCH))) {
          return SZ_ERROR_NOT_FINISHED;
        }
      }
      # This line can be triggered by passing LOCAL_VAR(ddSrcLen)=1 to LzmaDec_DecodeToDic.
      $bufCur = READBUF_SIZE;  # tempBuf.
      if (((LzmaDec_DecodeReal2(0, READBUF_SIZE)) != (SZ_OK))) {
        return SZ_ERROR_DATA;
      }
      $lookAhead -= $ddRem - ($bufCur - READBUF_SIZE);
      $readCur += $lookAhead;
      $tempBufSize = 0;
    }
  }
  if (NE0[$code]) { return SZ_ERROR_DATA; }
  return SZ_ERROR_FINISHED_WITH_MARK;
}

# Tries to preread r bytes to the read buffer. Returns the number of bytes
# * available in the read buffer. If smaller than r, that indicates EOF.
# *
# * Doesn't try to preread more than absolutely necessary, to avoid copies in
# * the future.
# *
# * Works only if LE_SMALL(prereadPos, READBUF_SIZE).
# *
# * Maximum allowed prereadSize is READBUF_SIZE (< 66000).
sub Preread($) { my $prSize = $_[0];
  my $prPos = $readEnd - $readCur;
  my $prGot;
  if ((($prPos) < ($prSize))) {  # Not enough pending available.
    if (((READBUF_SIZE - $readCur) < ($prSize))) {
      # If no room for LOCAL_VAR(prSize) bytes to the end, discard bytes from the beginning.
      for ($readEnd = 0; (($readEnd) < ($prPos)); ++$readEnd) {
        vec($readBuf, $readEnd, 8) = vec($readBuf, $readCur + $readEnd, 8);
      }
      $readCur = 0;
    }
    while ((($prPos) < ($prSize))) {
      # Instead of (LOCAL_VAR(prSize) - LOCAL_VAR(prPos)) we could use (GLOBAL_VAR(readBuf) + READBUF_SIZE -
      # * GLOBAL_VAR(readEnd)) to read as much as the buffer has room for.
      $prGot = UndefToMinus1(sysread(STDIN, $readBuf, ($prSize - $prPos), ($readEnd)));
      if ((($prGot + 1) <= (1))) { last; }  # EOF or error on input.
      $readEnd += $prGot;
      $prPos += $prGot;
    }
  }
  return $prPos;
}

sub IgnoreVarint() {
  while (((vec($readBuf, $readCur++, 8)) >= (0x80))) {}
}

sub IgnoreZeroBytes($) { my $izCount = $_[0];
  for (; (($izCount) != (0)); --$izCount) {
    if (((vec($readBuf, $readCur++, 8)) != (0))) {
      return SZ_ERROR_BAD_PADDING;
    }
  }
  return SZ_OK;
}

sub GetLE4($) { my $glPos = $_[0];
  return vec($readBuf, $glPos, 8) | vec($readBuf, $glPos + 1, 8) << 8 | vec($readBuf, $glPos + 2, 8) << 16 | vec($readBuf, $glPos + 3, 8) << 24;
}

# Expects GLOBAL_VAR(dicSize) be set already. Can be called before or after InitProp.
sub InitDecode() {
  # needInitProp will initialize it
  # SET_GLOBAL(lc, 106, =) SET_GLOBAL(pb, 108, =) SET_GLOBAL(lp, 110, =) 0;
  $dicBufSize = 0;  # We'll increment it later.
  $needInitDic = TRUE;
  $needInitState = TRUE;
  $needInitProp = TRUE;
  $dicPos = 0;
  LzmaDec_InitDicAndState(TRUE, TRUE);
}

sub InitProp($) { my $ipByte = $_[0];
  if ((($ipByte) >= (9 * 5 * 5))) { return SZ_ERROR_BAD_LCLPPB_PROP; }
  $lc = $ipByte % 9;
  $lcm8 = 8 - $lc;
  $ipByte /= 9;
  $pb = $ipByte / 5;
  $lp = $ipByte % 5;
  if ((($lc + $lp) > (LZMA2_LCLP_MAX))) { return SZ_ERROR_BAD_LCLPPB_PROP; }
  $needInitProp = FALSE;
  return SZ_OK;
}

# Writes uncompressed data dic[LOCAL_VAR(fromDicPos) : GLOBAL_VAR(dicPos)] to stdout.
sub WriteFrom($) { my $wfDicPos = $_[0];
  while ((($wfDicPos) != ($dicPos))) {
    my $wfGot = UndefToMinus1(syswrite(STDOUT, $dic, ($dicPos - $wfDicPos), ($wfDicPos)));
    if ($wfGot & 0x80000000) { return SZ_ERROR_WRITE; }
    $wfDicPos += $wfGot;
  }
  return SZ_OK;
}

# Reads .xz or .lzma data from stdin, writes uncompressed bytes to stdout,
# * uses GLOBAL_VAR(dic). It verifies some aspects of the file format (so it
# * can't be tricked to an infinite loop etc.), itdoesn't verify checksums
# * (e.g. CRC32).
sub DecompressXzOrLzma() {
  my $checksumSize;
  my $bhf;  # Block header flags
  my $dxRes;

  # 12 for the stream header + 12 for the first block header + 6 for the
  # * first chunk header. empty.xz is 32 bytes.
  if (((Preread(12 + 12 + 6)) < (12 + 12 + 6))) { return SZ_ERROR_INPUT_EOF; }
  # readBuf[6] is actually stream flags, should also be 0.
  if (((vec($readBuf, 0, 8)) == (0xfd)) && ((vec($readBuf, 1, 8)) == (0x37)) &&
      ((vec($readBuf, 2, 8)) == (0x7a)) && ((vec($readBuf, 3, 8)) == (0x58)) &&
      ((vec($readBuf, 4, 8)) == (0x5a)) && ((vec($readBuf, 5, 8)) == (0)) &&
      ((vec($readBuf, 6, 8)) == (0))) {  # .xz: "\xFD""7zXZ\0"
  } elsif (((vec($readBuf, $readCur, 8)) <= (225)) && ((vec($readBuf, $readCur + 13, 8)) == (0)) &&  # .lzma
        # High 4 bytes of uncompressed size.
        (EQ0[($bhf = GetLE4($readCur + 9))] || EQ0[~$bhf]) &&
        ((($dicSize = GetLE4($readCur + 1))) >= (LZMA_DIC_MIN)) &&
        LTX[$dicSize],[DIC_ARRAY_SIZE + 1]) {
    # Based on https://svn.python.org/projects/external/xz-5.0.3/doc/lzma-file-format.txt
    my $readBufUS;
    my $srcLen;
    my $fromDicPos;
    InitDecode();
    # LZMA restricts LE_SMALL(lc + lp, 4). LZMA requires LE_SMALL(lc + lp,
    # * 12). We apply the LZMA2 restriction here (to save memory in
    # * GLOBAL_VAR(probs)), thus we are not able to extract some legitimate
    # * .lzma files.
    if (((($dxRes = InitProp(vec($readBuf, $readCur, 8)))) != (SZ_OK))) {
      return $dxRes;
    }
    if (EQ0[$bhf]) {
      $dicBufSize = $readBufUS = GetLE4($readCur + 5);
      if (!LTX[$readBufUS],[DIC_ARRAY_SIZE + 1]) { return SZ_ERROR_MEM; }
    } else {
      $readBufUS = $bhf;  # max UInt32.
      $dicBufSize = DIC_ARRAY_SIZE;
    }
    $readCur += 13;  # Start decompressing the 0 byte.
    # TODO(pts): Limit on uncompressed size unless 8 bytes of -1 is
    # * specified.
    # Any Preread(...) amount starting from 1 works here, but higher values
    # * are faster.
    while (((($srcLen = Preread(READBUF_SIZE))) != (0))) {
      $fromDicPos = $dicPos;
      $dxRes = LzmaDec_DecodeToDic($srcLen);
      if ((($dicPos) > ($readBufUS))) { $dicPos = $readBufUS; }
      if (((($dxRes = WriteFrom($fromDicPos))) != (SZ_OK))) { return $dxRes; }
      if ((($dxRes) == (SZ_ERROR_FINISHED_WITH_MARK))) { last; }
      if ((($dxRes) != (SZ_ERROR_NEEDS_MORE_INPUT)) && (($dxRes) != (SZ_OK))) { return $dxRes; }
      if ((($dicPos) == ($readBufUS))) { last; }
    }
    return SZ_OK;
  } else {
    return SZ_ERROR_BAD_MAGIC;
  }
  # Based on https://tukaani.org/xz/xz-file-format-1.0.4.txt
  $checksumSize = vec($readBuf, $readCur + 7, 8);
  if ((($checksumSize) == (0))) {  # None
 $checksumSize = 1; }
  elsif ((($checksumSize) == (1))) {  # CRC32
 $checksumSize = 4; }
  elsif ((($checksumSize) == (4))) {  # CRC64, typical xz output.
 $checksumSize = 8; }
  else { return SZ_ERROR_BAD_CHECKSUM_TYPE; }
  # Also ignore the CRC32 after LOCAL_VAR(checksumSize).
  $readCur += 12;
  for (;;) {  # Next block.
    # We need it modulo 4, so a Byte is enough.
    my $blockSizePad = 3;
    my $bhs;
    my $bhs2;  # Block header size
    my $dicSizeProp;
    my $readAtBlock;
    $readAtBlock = $readCur;
    # Last block, index follows.
    if (((($bhs = vec($readBuf, $readCur++, 8))) == (0))) { last; }
    # Block header size includes the LOCAL_VAR(bhs) field above and the CRC32 below.
    $bhs = ($bhs + 1) << 2;
    # Typically the Preread(12 + 12 + 6) above covers it.
    if (((Preread($bhs)) < ($bhs))) { return SZ_ERROR_INPUT_EOF; }
    $readAtBlock = $readCur;
    $bhf = vec($readBuf, $readCur++, 8);
    if ((($bhf & 2) != (0))) { return SZ_ERROR_UNSUPPORTED_FILTER_COUNT; }
    if ((($bhf & 20) != (0))) { return SZ_ERROR_BAD_BLOCK_FLAGS; }
    if ((($bhf & 64) != (0))) {  # Compressed size present.
      # Usually not present, just ignore it.
      IgnoreVarint();
    }
    if ((($bhf & 128) != (0))) {  # Uncompressed size present.
      # Usually not present, just ignore it.
      IgnoreVarint();
    }
    # This is actually a varint, but it's shorter to read it as a byte.
    if (((vec($readBuf, $readCur++, 8)) != (FILTER_ID_LZMA2))) { return SZ_ERROR_UNSUPPORTED_FILTER_ID; }
    # This is actually a varint, but it's shorter to read it as a byte.
    if (((vec($readBuf, $readCur++, 8)) != (1))) { return SZ_ERROR_UNSUPPORTED_FILTER_PROPERTIES_SIZE; }
    $dicSizeProp = vec($readBuf, $readCur++, 8);
    # Typical large dictionary sizes:
    # *
    # *  * 35: 805306368 bytes == 768 MiB
    # *  * 36: 1073741824 bytes == 1 GiB
    # *  * 37: 1610612736 bytes, largest supported by .xz
    # *  * 38: 2147483648 bytes == 2 GiB
    # *  * 39: 3221225472 bytes == 3 GiB
    # *  * 40: 4294967295 bytes, largest supported by .xz
    if ((($dicSizeProp) > (40))) { return SZ_ERROR_BAD_DICTIONARY_SIZE; }
    # LZMA2 and .xz support it, we don't (for simpler memory management on
    # * 32-bit systems).
    if ((($dicSizeProp) > (37))) { return SZ_ERROR_UNSUPPORTED_DICTIONARY_SIZE; }
    $dicSize = (((2) | (($dicSizeProp) & 1)) << (($dicSizeProp) / 2 + 11));
    $bhs2 = $readCur - $readAtBlock + 5;  # Won't overflow.
    if ((($bhs2) > ($bhs))) { return SZ_ERROR_BLOCK_HEADER_TOO_LONG; }
    if (((($dxRes = IgnoreZeroBytes($bhs - $bhs2))) != (SZ_OK))) { return $dxRes; }
    $readCur += 4;  # Ignore CRC32.
    # Typically it's LOCAL_VAR(offset) 24, xz creates it by default, minimal.
    {  # Parse LZMA2 stream.
      # Based on https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm#LZMA2_format
      my $chunkUS;  # Uncompressed chunk sizes.
      my $chunkCS;  # Compressed chunk size.
      my $initDic;
      InitDecode();

      for (;;) {
        my $control;
        # Actually 2 bytes is enough to get to the index if everything is
        # * aligned and there is no block checksum.
        if (((Preread(6)) < (6))) { return SZ_ERROR_INPUT_EOF; }
        $control = vec($readBuf, $readCur, 8);
        if ((($control) == (0))) {
          ++$readCur;
          last;
        } elsif ((((($control - 3) & 0xff)) < (0x80 - 3))) {
          return SZ_ERROR_BAD_CHUNK_CONTROL_BYTE;
        }
        $chunkUS = (vec($readBuf, $readCur + 1, 8) << 8) + vec($readBuf, $readCur + 2, 8) + 1;
        if ((($control) < (3))) {  # Uncompressed chunk.
          $initDic = (($control) == (1));
          $chunkCS = $chunkUS;
          $readCur += 3;
          # TODO(pts): Porting: TRUNCATE_TO_8BIT(LOCAL_VAR(blockSizePad)) for Python and other unlimited-integer-range languages.
          $blockSizePad -= 3;
          if ($initDic) {
            $needInitProp = $needInitState = TRUE;
            $needInitDic = FALSE;
          } elsif ($needInitDic) {
            return SZ_ERROR_DATA;
          }
          LzmaDec_InitDicAndState($initDic, FALSE);
        } else {  # LZMA chunk.
          my $mode = (((($control)) >> (5)) & 3);
          my $initState = (($mode) != (0));
          my $isProp = ((($control & 64)) != (0));
          $initDic = (($mode) == (3));
          $chunkUS += ($control & 31) << 16;
          $chunkCS = (vec($readBuf, $readCur + 3, 8) << 8) + vec($readBuf, $readCur + 4, 8) + 1;
          if ($isProp) {
            if (((($dxRes = InitProp(vec($readBuf, $readCur + 5, 8)))) != (SZ_OK))) {
              return $dxRes;
            }
            ++$readCur;
            --$blockSizePad;
          } else {
            if ($needInitProp) { return SZ_ERROR_MISSING_INITPROP; }
          }
          $readCur += 5;
          $blockSizePad -= 5;
          if ((!$initDic && $needInitDic) || (!$initState && $needInitState)) {
            return SZ_ERROR_DATA;
          }
          LzmaDec_InitDicAndState($initDic, $initState);
          $needInitDic = FALSE;
          $needInitState = FALSE;
        }
        $dicBufSize += $chunkUS;
        # Decompressed data too long, won't fit to GLOBAL_VAR(dic).
        if ((($dicBufSize) > (DIC_ARRAY_SIZE))) { return SZ_ERROR_MEM; }
        # Read 6 extra bytes to optimize away a read(...) system call in
        # * the Prefetch(6) call in the next chunk header.
        if (((Preread($chunkCS + 6)) < ($chunkCS))) { return SZ_ERROR_INPUT_EOF; }
        if ((($control) < (0x80))) {  # Uncompressed chunk.
          while ((($dicPos) != ($dicBufSize))) {
            vec($dic, $dicPos++, 8) = vec($readBuf, $readCur++, 8);
          }
          if ((($checkDicSize) == (0)) && (($dicSize - $processedPos) <= ($chunkUS))) {
            $checkDicSize = $dicSize;
          }
          $processedPos += $chunkUS;
        } else {  # Compressed chunk.
          # This call doesn't change GLOBAL_VAR(dicBufSize).
          if (((($dxRes = LzmaDec_DecodeToDic($chunkCS))) != (SZ_OK))) { return $dxRes; }
        }
        if ((($dicPos) != ($dicBufSize))) { return SZ_ERROR_BAD_DICPOS; }
        if (((($dxRes = WriteFrom($dicPos - $chunkUS))) != (SZ_OK))) { return $dxRes; }
        $blockSizePad -= $chunkCS;
        # We can't discard decompressbuf[:GLOBAL_VAR(dicBufSize)] now,
        # * because we need it a dictionary in which subsequent calls to
        # * Lzma2Dec_DecodeToDic will look up backreferences.
      }
    }  # End of LZMA2 stream.
    # End of block.
    # 7 for padding4 and CRC32 + 12 for the next block header + 6 for the next
    # * chunk header.
    if (((Preread(7 + 12 + 6)) < (7 + 12 + 6))) { return SZ_ERROR_INPUT_EOF; }
    # Ignore block padding.
    if (((($dxRes = IgnoreZeroBytes($blockSizePad & 3))) != (SZ_OK))) { return $dxRes; }
    $readCur += $checksumSize;  # Ignore CRC32, CRC64 etc.
  }
  # The .xz input file continues with the index, which we ignore from here.
  return SZ_OK;
}
sub Decompress() {
  my $deRes;
  $probs = '';
  $readBuf = '';
  $dic = '';
  binmode(STDIN);
  binmode(STDOUT);
  $deRes = DecompressXzOrLzma();
  $probs = '';
  $readBuf = '';
  $dic = '';
  return $deRes;
}
ENDEVAL
my $lta; my $ltb;
if ((1 << 31) < 0) {  # 32-bit Perl.
  s@\bLT\[([^\]]+)\],\[([^\]]+)\]@(\$lta = ($1) & 0xffffffff, \$ltb = ($2) & 0xffffffff, (\$lta < 0 ? \$ltb >= 0 : \$ltb < 0) ? \$ltb < 0 : \$lta < \$ltb)@g;
  s@\bLTX\[([^\]]+)\],\[([^\]]+)\]@(\$lta = ($1) & 0xffffffff, \$lta < ($2) && \$lta >= 0)@g;
  s@\bEQ0\[([^\]]+)\]@!($1)@g;
  s@\bNE0\[([^\]]+)\]@(($1) != 0)@g;
} else {  # At least 33-bit Perl, typically 64-bit.
  # This is faster than the LT above.
  s@\bLT\[([^\]]+)\],\[([^\]]+)\]@((($1) & 0xffffffff) < (($2) & 0xffffffff))@g;
  s@\bLTX\[([^\]]+)\],\[([^\]]+)\]@((($1) & 0xffffffff) < ($2))@g;
  s@\bEQ0\[([^\]]+)\]@!(($1) & 0xffffffff)@g;
  s@\bNE0\[([^\]]+)\]@((($1) & 0xffffffff) != 0)@g;
}
eval; die $@ if $@ }

exit(Decompress())
